<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD with OASIS Tables with MathML3 v1.1 20151215//EN"
  "JATS-journalpublishing-oasis-article1-mathml3.dtd">
<article dtd-version="1.1" xml:lang="en" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <front>
    <journal-meta>
      <journal-id>E-ED</journal-id>
      <journal-title-group>
        <journal-title>e-editiones Blog</journal-title>
      </journal-title-group>
    </journal-meta>
    <article-meta>
      <title-group>
        <article-title>Generating a high voltage site by going static</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Meier</surname>
            <given-names>Wolfgang</given-names>
          </name>
        </contrib>
      </contrib-group>
      <pub-date iso-8601-date="2022-12-06" publication-format="web">
        <day>6</day>
        <month>12</month>
        <year>2022</year>
      </pub-date>
      <related-article related-article-type="version-of-record" xlink:href="https://www.e-editiones.org/posts/community-event-going-static/"/>
      <abstract>
        <p>Sometimes you don't need a fully dynamic website with sophisticated search and navigation,
          but rather a simple service, which is fast, cheap and easy to maintain. This is where static
          site generators provide a perfect alternative to a dynamic, database-driven architecture like
          TEI Publisher. In this article we'll learn how to combine the best of both worlds.</p>
      </abstract>
      <kwd-group kwd-group-type="genre">
        <kwd>Documentation</kwd>
      </kwd-group>
    </article-meta>
  </front>
  <body>
    <sec>
      <title>Benefits of a static site</title>
      <p>A static website is generated once during build time and does not change afterwards. All
        content is prepared in advance and the output is essentially just a set of files. The only
        job left for a server is to respond to requests by returning the prepared content. It does
        not need to process anything. This has a number of advantages:</p>
      <list list-type="bullet">
        <list-item>
          <p>the site will be as fast as it can possibly be</p>
        </list-item>
        <list-item>
          <p>hosting is cheap: you can mostly get it for free</p>
        </list-item>
        <list-item>
          <p>you'll get an entirely self-sufficient, frozen snapshot of your content: ideal for
            archiving purposes</p>
        </list-item>
        <list-item>
          <p>static content is perfect for mobile applications, which should continue to work when
            offline</p>
        </list-item>
      </list>
      <p>For sure there are also some downsides: since everything is pre-generated, you have to know
        in advance what users might request. Dynamic functions like search are thus necessarily
        limited.</p>
      <p>In the context of digital editions, there are nevertheless many use cases where a static
        site might be a viable option:</p>
      <list list-type="bullet">
        <list-item>
          <p>the edition is rather small, i.e. concentrates on a single or a small collection of
            works</p>
        </list-item>
        <list-item>
          <p>users are more interested in reading and browsing than complex searches</p>
        </list-item>
        <list-item>
          <p>only a part of the site displays content generated from XML, while the rest remains
            static</p>
        </list-item>
        <list-item>
          <p>you want to ensure that the content can stay online for a long time with no or low
            maintenance</p>
        </list-item>
      </list>
      <p>The last point is addressing a problem we all face sooner or later: we created a fancy, TEI
        Publisher-powered website, but then the funding period ends and the university library tells
        us: sorry, we can only archive static content, not applications requiring a database. So
        having a – maybe slightly stripped down – static snapshot will at least allow potential
        users to dig up your site and look at it long after you switched jobs or retired.</p>
      <sec id="integrating-tei">
        <title>Integrating TEI</title>
        <p>A number of frameworks are available to help you create a static website. The e-editiones
          homepage is an example for this approach: it is based on a static website generator called
            <ext-link ext-link-type="uri" xlink:href="https://www.11ty.dev/">11ty</ext-link>.
          Articles are written using markdown syntax and the generator takes care to transform each
          article and wrap it into the site’s HTML templates. It works great and – thanks to github
          – the hosting is free<fn><p>Via <ext-link xlink:href="https://pages.github.com/">GitHub Pages</ext-link>.</p></fn>.</p>
        <p>Digital editions are rarely based on markdown though. Can we integrate TEI or other XML
          content as well? Some might say: we can always write an XSLT to generate HTML and add this
          to our static site. But this means we’d loose most of the nice features a system like TEI
          Publisher provides and have to reimplement them. Is there an easier way?</p>
        <p>At this point you may want to browse to a (currently) <ext-link ext-link-type="uri"
            xlink:href="https://e-editiones.org/pages/tei-publisher/documentation">hidden page</ext-link> on the
          e-editiones website. What we see there is a static version of the latest TEI Publisher
          documentation! And we all know that the documentation is written in Docbook XML. So how
          did it get there? The mystery will be revealed in a minute…</p>
        <fig>
          <caption>
            <p>TEI Publisher documentation in e-editiones</p>
          </caption>
          <graphic mimetype="image" mime-subtype="png" xlink:href="tei-publisher-docs.png"/>
        </fig>
        <p>If you investigate the <ext-link ext-link-type="uri"
            xlink:href="https://github.com/eeditiones/e-editiones-website/blob/main/pages/tei-publisher/documentation.njk"
            >source code</ext-link> for this page, you’ll notice that it appears to be more or less
          like any HTML template in TEI Publisher (apart from the fact that it uses a different
          templating system to pull in the e-editiones header, menu etc.). We see all the familiar
          webcomponents like <monospace>&lt;pb-document&gt;</monospace>,
            <monospace>&lt;pb-navigation&gt;</monospace> etc. The main
            <monospace>&lt;pb-view&gt;</monospace> which displays the body of the content reads as
          follows:</p>
        <code language="html">&lt;pb-view id=&quot;view1&quot; src=&quot;document1&quot; append-footnotes=&quot;append-footnotes&quot; subscribe=&quot;transcription&quot; emit=&quot;transcription&quot;
    static=&quot;&quot; no-scroll&gt;
&lt;/pb-view&gt;</code>
        <p>The only noticable difference is the additional attribute
            <monospace>static=&quot;&quot;</monospace> – and this is where the magic happens!
          Obviously this attribute tells <monospace>&lt;pb-view&gt;</monospace> that - instead of
          connecting to its usual home base, i.e. a TEI Publisher instance – it should load the
          content from local, static files. We’ll discuss later how this is done.</p>
        <p>The unique selling point of this approach is: we can just continue to use nearly all of
          TEI Publisher’s webcomponents! They will <bold>work as before</bold> on a dynamic site,
          which means we have page-by-page or division-by-division navigation out of the box, we can
          add facsimiles via <monospace>&lt;pb-facsimile&gt;</monospace>, switch between diplomatic
          or reading views via <monospace>&lt;pb-toggle&gt;</monospace>, and so on. At the same
          time, you can see that the components integrate nicely with the look and feel of the
          e-editiones website, which – unlike TEI Publisher – uses Bootstrap for basic styling.</p>
        <p>But can we also create a snapshot of an entire website we developed with TEI Publisher?
          Head over to our copy of the <ext-link ext-link-type="uri"
            xlink:href="https://guidelines.teipublisher.com">TEI P5 guidelines</ext-link>. This app
          was first developed as a dynamic TEI Publisher application and then transformed into a
          static version. Besides browsing through the chapters of the guidelines, the app also
          includes all the reference pages. There’s even some dynamic functionality: you can jump to
          a reference page for an element or class by typing into the corresponding search box and
          there will be an autocomplete popping up. There’s also a simple search facility!</p>
        <p/>
        <fig position="float">
          <caption>
            <p>TEI Guidelines as a mobile app</p>
          </caption>
          <graphic xlink:href="guidelines_mobile.jpg"></graphic>
        </fig>
        
        <p>Also worth mentioning: the static version of the <ext-link ext-link-type="uri"
            xlink:href="https://guidelines.teipublisher.com">TEI guidelines app</ext-link> is a
          so-called <bold>progressive web app</bold>, which means you can install it as a standalone
          application. This is most useful on a phone or tablet as visited pages will be cached for
          offline use. I’m actually using the guidelines app on the phone quite often, e.g. if I
          have to look up something while travelling. What is cached or preloaded for offline use is
          fully configurable in the generator, so you could even preload all the content and be
          fully independent of a network connection.</p>
        <p>A﻿s you can see in the screenshot, Chrome on Android displays a notification suggesting
          that you can install the page as an app. On a desktop machine, you should see an icon next
          to the location bar offering the same.</p>
      </sec>
      <sec id="how-does-it-work">
        <title>How does it work?</title>
        <p>During the past year we actually implemented two different approaches for generating
          static content from TEI Publisher. The <ext-link ext-link-type="uri"
            xlink:href="https://github.com/eeditiones/tei-publisher-static">first
          project</ext-link>, which I started last winter, is written in Python. It is fully
          functional, providing the same features as the second approach. However, I ended up coding
          all those features myself, basically creating our own static site generator. This works
          fine as long as your goal is to create a static snapshot of a dynamic publisher-based
          site.</p>
        <p>A few months later, we decided to redo the e-editiones homepage and settled on <ext-link
            ext-link-type="uri" xlink:href="https://www.11ty.dev/">11ty</ext-link> as static site
          generator. The beauty of 11ty lies in its simplicity: it does one job and does it well. It
          does not impose a particular structure or choice of libraries, and it’s easy to extend the
          functionality via plugins. For e-editiones we started with a plain, empty template, added
          Bootstrap for basic styling, and thought out a system of tags to organize the content.
          Compared to other static site generators we’ve used, the learning curve was quite low.</p>
        <p>Triggered by this experience, I created a TEI Publisher plugin for 11ty. Unlike the
          Python version, it concentrates on integrating the content coming from TEI Publisher and
          leaves everything else to 11ty and its other plugins.</p>
        <p>The TEI Publisher plugin works as follows: it installs a filter to scan the HTML content
          produced by 11ty for each page, watching out for <monospace>pb-view</monospace> components
          being used. As we all know, <monospace>pb-view</monospace> is the main component in
          publisher for displaying a TEI document. For each <monospace>pb-view</monospace> the
          plugin mimics what a user would do when reading through the document page by page. For
          every page, the response returned by TEI Publisher is saved as a file (after applying some
          normalization steps). The plugin also remembers the URL parameters which were used to
          retrieve the page and writes them into a <ext-link ext-link-type="uri"
            xlink:href="https://github.com/eeditiones/e-editiones-website/blob/gh-pages/pages/tei-publisher/documentation/index.json"
            >mapping table</ext-link>.</p>
        <p>When we switch the <monospace>pb-view</monospace> to static mode (by adding the attribute
            <monospace>static=&quot;&quot;</monospace>), it will use the mapping table to resolve
          its current combination of URL parameters and loads the corresponding static file instead
          of trying to connect to the URL. It’s as simple as that! For sure, there’s more going on
          behind the scenes, but as a user, you don’t have to know anything about it. Just use
            <monospace>pb-view</monospace> in your template and the rest happens automagically.</p>
      </sec>
      <sec id="configuration">
        <title>Configuration</title>
        <p>There are two ways to install 11ty and the TEI Publisher plugin:</p>
        <list list-type="order">
          <list-item>
            <p>clone one of the existing <ext-link ext-link-type="uri"
                xlink:href="https://www.11ty.dev/docs/starter/">11ty starter projects</ext-link>
              templates and add the TEI Publisher plugin</p>
          </list-item>
          <list-item>
            <p>copy our <ext-link ext-link-type="uri"
                xlink:href="https://github.com/eeditiones/tei-publisher-eleventy-starter">minimal
                template</ext-link>, which offers a very basic setup</p>
          </list-item>
        </list>
        <p>The plugin is distributed via <monospace>npm</monospace> (= the nodejs package manager).
          Using option 1) you can add the plugin to your project by running <monospace>npm install
            --save @teipublisher/pb-eleventy-plugin</monospace>. Option 2) already includes it.</p>
        <p>All configuration for 11ty is done in a central javascript file located in the root of
          the project: <monospace>.eleventy.js</monospace>. This might appear a bit scary for those
          with no javascript experience, but it is actually easy enough. The most basic
          configuration to include the publisher plugin would look like this:</p>
        <code language="javascript">const tpPlugin = require(&quot;@teipublisher/pb-eleventy-plugin&quot;);

module.exports = (eleventyConfig) =&gt; {
    // copy css
    eleventyConfig.addPassthroughCopy('src/resources/css');
    
    eleventyConfig.addPlugin(tpPlugin, {
        remote: 'http://localhost:8080/exist/apps/tei-publisher/'
    });

    return {
        dir: {
          input: &quot;src&quot;,
          output: &quot;_site&quot;
        }
    }
};</code>
        <p>The plugin gets registered in 11ty by calling
            <monospace>eleventyConfig.addPlugin</monospace>. The second parameter contains the
          configuration parameters you would like to pass to the plugin. The one required option
            (<monospace>remote</monospace>) specifies the base URI of the TEI Publisher instance we
          would like to use for our XML transformations.</p>
      </sec>
      <sec id="more-features">
        <title>More features</title>
        <sec id="pre-fetching-content">
          <title>Pre-fetching content</title>
          <p>Besides <monospace>pb-view</monospace>, there’s another component in TEI Publisher
            which is commonly used to load dynamic content into the page:
              <monospace>pb-load</monospace>. For example, we usually retrieve the table of contents
            for a document via <monospace>pb-load</monospace>. This will only be loaded once for the
            entire document though, so the most efficient way to integrate it into our static
            content would actually be to just insert the table of contents into the HTML.</p>
          <p>So as an alternative to <monospace>pb-load</monospace>, the plugin thus defines a
            so-called <bold>shortcode</bold> which can be added to the HTML template at the point
            where the table of contents should appear. The templating engine will replace the
            shortcode with the content it produced.</p>
          <p>The shortcode <monospace>tpfetch</monospace> expects a URL from which to retrieve
            content and inserts whatever it received as a response into the final HTML. So to
            pre-load the table of contents for the TEI guidelines, we can call the corresponding TEI
            Publisher API endpoint:</p>
          <preformat>{%raw%}{% tpfetch tpConfig.remote + &quot;api/document/p5.xml/contents?target=transcription&amp;icons=true&quot; %}{%endraw%}</preformat>
        </sec>
        <sec id="adding-information-to-global-data">
          <title>Adding information to global data</title>
          <p>Within an HTML template you can access metadata variables 11ty provides to you. These
            can be set via the metadata header of the template, data files in a directory or
            contributed by a plugin.</p>
          <p>The TEI Publisher plugin injects a number of global metadata objects. One example is
            the <monospace>tpConfig</monospace> object used above to determine the base URL of the
            TEI Publisher instance. <monospace>tpConfig</monospace> contains a copy of the
            configuration object currently used by the plugin.</p>
          <p>Sometimes you may also want to retrieve other information from TEI Publisher and make
            it available to templates. For example, the TEI guidelines generate a reference page for
            each element and class defined. But to do this, we need a list of element and class
            idents, which we can iterate over to generate the corresponding reference page.</p>
          <p>The plugin thus allows you to specify a set of URLs, from which content should be
            loaded and added to global metadata. For the guidelines app, the configuration looks
            like this:</p>
          <code language="javascript">// configure the TEI Publisher plugin
eleventyConfig.addPlugin(tpPlugin, {
    remote: 'http://localhost:8080/exist/apps/guidelines/',
    data: {
        // retrieve idents for all TEI elements and classes. Add the result
        // as a global data object, accessible via tpdata.idents. A reference 
        // page will be generated for each ident using 11ty pagination.
        &quot;idents&quot;: &quot;api/idents&quot;
    },
    index: {
        &quot;view1&quot;: indexContent,
        &quot;reference&quot;: indexReference
    }
});</code>
          <p>Here the <monospace>data</monospace> configuration option defines that the data
            retrieved from an API call to <monospace>api/idents</monospace> should be saved to the
            plugins’ global data object, <monospace>tpdata</monospace>, under the key
              <monospace>idents</monospace>. We can thus later access the list of idents to generate
            a reference page for each. This is done using 11ty’s <bold>pagination plugin</bold><fn><p>Read more about pagination in the <ext-link xlink:href="https://www.11ty.dev/docs/pagination/">11ty documentation</ext-link></p></fn> (see
            the corresponding template in the <ext-link ext-link-type="uri"
              xlink:href="https://github.com/wolfgangmm/tei-guidelines-static/blob/main/src/ref.njk"
              >guidelines source</ext-link>).</p>
        </sec>
        <sec id="fetching-collection-listings">
          <title>Fetching collection listings</title>
          <p>The default entry page into TEI Publisher allows you to browse through the collection
            hierarchy. This is handled by the <monospace>pb-browse-docs</monospace> webcomponent. To
            provide the same functionality on a static site, we need to pre-load the corresponding
            data as well. This happens automatically if you specify <monospace>collections:
              true</monospace> in the plugin configuration.</p>
          <p>On your browsing page, make sure to include the extra attribute
              <monospace>static=&quot;&quot;</monospace> on any
              <monospace>pb-browse-docs</monospace> element. Just as for
              <monospace>pb-view</monospace>, this will cause <monospace>pb-browse-docs</monospace>
            to load the document listings from local files.</p>
          <p>In addition to fetching the content displayed by <monospace>pb-browse-docs</monospace>,
            this will also add another global data object, <monospace>tpdocuments</monospace>.
              <monospace>tpdocuments</monospace> contains metadata for each document, grouped by the
            name of the HTML template assigned by TEI Publisher for this document. So, for example,
            we’ll find metadata for Kant’s Kritik under <monospace>tpdocuments.dta</monospace> as
            this document is handled by the <monospace>dta</monospace> template in publisher:</p>
          <code language="json">{
    &quot;dta&quot;: {
        &quot;path&quot;: &quot;test/kant_rvernunft_1781.TEI-P5.xml&quot;,
        &quot;odd&quot;: &quot;dta.odd&quot;,
        &quot;view&quot;: &quot;page&quot;
    }
}</code>
          <p>Again we can later use this information in our HTML templates, e.g. to generate one
            page for each document using the same <monospace>dta</monospace> template.</p>
        </sec>
      </sec>
      <sec id="outlook">
        <title>Outlook</title>
        <p>We successfully tested the 11ty plugin in various context. The TEI guidelines app
          demonstrates how you can create a static snapshot of a complete publisher-generated app.
          It worked so well that we will likely drop the dynamic app and continue further
          development on the static version only. Mid-term, the goal is to generate the entire TEI
          guidelines documentation on the command line without requiring a full TEI Publisher
          installation.</p>
        <p>To some extent this is already possible as demonstrated by the automatic build, which is
          triggered whenever one pushes to the repository: it will start TEI Publisher as a docker
          image, launch 11ty to generate the static content and publish it.</p>
        <p>It would be even better if we could skip the docker step. As discussed during the last
          TEI conference, we’re already working to refactor the core library powering all
          transformations in TEI Publisher, i.e. tei-publisher-lib, to run with other XQuery
          engines, which would include e.g. saxon on the command line, thus dropping the need for an
          eXist-db/TEI Publisher installation.</p>
      </sec>
    </sec>
  </body>
</article>
