<?teipublisher odd="docbook.odd" template="documentation.html" depth="5" fill="2" media="latex,print,fo,epub"?>
<?xml-model href="https://docbook.org/xml/5.0/xsd/docbook.xsd" type="application/xml" schematypens="http://www.w3.org/2001/XMLSchema"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
  version="5.0" xml:lang="en">
  <info>
    <title>TEI Publisher Documentation</title>
    <author>
      <orgname>TEI Publisher Community</orgname>
    </author>
    <keywordset vocab="#genre">
      <keyword>Documentation</keyword>
    </keywordset>
  </info>
  <section xml:id="introduction">
    <title>Introduction</title>
    <section xml:id="introduction-explainer">
      <title>What TEI Publisher does ...</title>
      <para> The motivation behind TEI Publisher was to provide a tool which enables scholars and
        editors to publish their materials without becoming programmers, but also does not force
        them into a one-size-fits-all framework. Experienced developers will benefit as well by
        writing less code, avoiding redundancy, improve maintenance and interoperability - to just
        name a few. TEI Publisher is all about <emphasis role="bold">standards</emphasis> , <emphasis
          role="bold">modularity</emphasis> , <emphasis role="bold">reusability</emphasis> and <emphasis
          role="bold">sustainability</emphasis> ! </para>
      <para>In Publisher, it all starts with your source documents - regardless if they are in TEI
        or other form of XML: DocBook, MS Word (DOCX) or JATS. No matter how the source material has
        been encoded, it can be easily transformed into a range of output formats for publication -
        from a modern web page that you can open on your laptop or mobile device, to an ebook, a PDF
        file or its LaTeX source.</para>
      <para> TEI Publisher derives its name from TEI and the TEI Processing Model (PM). Processing
        Model is a part of the TEI vocabulary and TEI ODD specification format, described in the <link
          xlink:show="new"
          xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/TD.html#TDPM">TEI P5
        guidelines</link> as well as further chapters here. It defines how a TEI document should be
        rendered in different output formats and lies at the heart of TEI Publisher. </para>
      <para>However, online editions require more than just a text transformation: the text needs to
        be embedded into an application context, adding navigation, pagination, search, facsimile
        display and so on. The larger part of TEI Publisher deals with those aspects, providing all
        the necessary building blocks for an online edition.</para>
      <para> Staying true to the spirit of code reuse and interoperability, TEI Publisher implements
        its functionalities as small "lego" blocks to be freely arranged and recombined. The
        technology making this possible is called <emphasis>Web Components</emphasis> . It is part
        of the HTML5 specification and natively implemented by many browsers. Users don't need to
        dive into the details of this standard though: all you need to modify the example pages is
        some basic HTML knowledge. </para>
      <para> Only where the <link xlink:show="new"
          xlink:href="https://cdn.tei-publisher.com/api.html">available
        components</link> are not enough, a new use case needs to be described and suitable new
        components implemented but then they can be incorporated into existing component pool for
        everyone else to use. After all, our mantra is reuse, reuse, reuse and we want to turn TEI
        Publisher into a box of tools the entire community can benefit from. </para>
      <para>Despite the elegant simplicity of this approach, various projects we realized in the
        past prove that TEI Publisher is:</para>
      <orderedlist>
        <listitem>
          <para>powerful enough to cover complex transformation needs</para>
        </listitem>
        <listitem>
          <para>a truly universal tool for any kind of digital edition</para>
        </listitem>
        <listitem>
          <para>capable of generating high quality, camera ready material for book publishing</para>
        </listitem>
        <listitem>
          <para>sustainable and future-proof solution</para>
        </listitem>
        <listitem>
          <para>suitable for any XML, not just TEI (this documentation is written in DocBook!)</para>
        </listitem>
      </orderedlist>
    </section>
    <section xml:id="e-editiones">
      <title>e-editiones.org</title>
      <para> Since its first incarnation in 2015, TEI Publisher has gained substantial following
        with numerous academic and commercial projects around the globe using it for their editorial
        and publishing needs. Grass-roots user initiative led in 2020 to the foundation of an
        international non-profit association <link xlink:show="new"
          xlink:href="https://e-editiones.org">e-editiones.org</link> with the focus on further
        joint development of TEI Publisher, open standards and best practices for digital editions. </para>

      <para>TEI Publisher development is only possible thanks to generous contributions of
        developers, users and institutions willing to employ Open Source approaches so that the
        whole community can reuse and benefit from their work.</para>

      <para> A growing number of projects from small to large that have decided to publish their
        materials with TEI Publisher gives us all not only the opportunity but also the
        responsibility to make the project thrive for years to come and to make it truly sustainable
        option for XML publishing! Consider joining <link xlink:show="new"
          xlink:href="https://e-editiones.org">e-editiones.org</link> through your affiliated
        institution or individually to support our efforts. </para>

      <para>We invite the community to contribute to the project - by means of code, ideas,
        documentation, tutorials and funding. </para>
      <para> You don't have to be a developer to contribute, you can do so in a number of ways! </para>

      <orderedlist>
        <listitem>
          <para>Check out the source code, modify it, document it, enhance it.</para>
        </listitem>
        <listitem>
          <para>Create new or enhance existing example documents and ODDs so we present showcases
            for various TEI applications.</para>
        </listitem>
        <listitem>
          <para> Report your issues, feature requests or ideas for discussion via <link
              xlink:show="new" xlink:href="https://github.com/eeditiones/tei-publisher-app/issues">GitHub
            issue tracker</link> . </para>
        </listitem>
        <listitem>
          <para> Discuss with us on <link xlink:show="new"
              xlink:href="https://join.slack.com/t/e-editiones/shared_invite/zt-e19jc03q-OFaVni~_lh6emSHen6pswg">e-editiones
            slack chat</link> or through the <link xlink:show="new"
              xlink:href="https://admin.hostpoint.ch/mailman/listinfo/community_e-editiones.org">mailing
            list</link> and <link xlink:show="new" xlink:href="https://twitter.com/EEditiones">@EEditiones
            twitter</link> . </para>
        </listitem>
        <listitem>
          <para> Contribute to translations via <link xlink:show="new"
              xlink:href="https://crwd.in/tei-publisher">Crowdin</link> . Please contact us if your
            target language is not listed and you'd like to work on it. </para>
        </listitem>
        <listitem>
          <para> Port back your custimizations to the TEI Publisher code base so that others can use
            it too (or ask us to do it for you)! </para>
        </listitem>
        <listitem>
          <para> Help and mentor others - publish teaching materials, answer questions on our Slack
            channel, mailing list and other forums. </para>
        </listitem>
        <listitem>
          <para> Sponsor a concrete feature or fund a development grant. </para>
        </listitem>
      </orderedlist>
    </section>
    <section xml:id="versions">
      <title>Versions</title>
      <para>TEI Publisher has been under active development since 2015. Once or twice a year a new
        major version is released, bringing important new features.</para>
      <para>Minor versions are released at shorter intervals and offer bug fixes, minor new features
        and improvements.</para>
      <para>The current major version of the TEI Publisher is 8.0.0</para>

      <para> There's a long list of ideas and features we'd like to see incorporated into TEI
        Publisher: from wider coverage of input and output formats (e.g. InDesign), CQL and DTS
        support, to various editing workflows and support for efficient hosting and maintenance of
        multiple editions. These ideas are in various stages of development - some already advanced,
        some in conceptual phase, some waiting for funding and implementation. Coordination of
        future work is primarily conducted by <link xlink:show="new"
          xlink:href="https://e-editiones.org">e-editiones.org</link>. </para>
      <section xml:id="v8">
        <title>What's new in TEI Publisher 8.0.0</title>
        <para>Version 8 has been focused on a major rework of the URL handling and redesign of
          search facilities. A number of further examples gives a better idea of the projects
          already using TEI Publisher for their editions. There have also been significant changes
          to connected resources: the tei-publisher-lib, webcomponents library and roaster.</para>
        <para>See chapter on <link linkend="updating">Updating</link> for information how to update
          your app to the newest version.</para>
      </section>
      <section xml:id="v7">
        <title>What's new in TEI Publisher 7.0.0</title>
        <para>Version 7 brought another major refactoring and restructuring of TEI Publisher app ,
          particularly regarding the server-side modules.</para>
        <para> TEI Publisher now exposes a well-defined, clear <link xlink:href="../api.html"
            xlink:show="new">API specification</link> following the <link xlink:show="new"
            xlink:href="http://spec.openapis.org/oas/v3.0.3">Open API standard</link> . This API is
          used in TEI Publisher by client-side UI components but can be equally well utilized by
          independent software which harnesses functionality exposed via the API without being
          forced to rely on Publisher's client-side components. </para>
        <para> On the server a new package, <filename>oas-router</filename> , reads the API
          specification and uses it to map HTTP requests to XQuery functions which perform actual
          API operations. Other packages, particularly UI web components ( <filename>pb-components</filename>
          ) and TEI Processing Model library ( <filename>tei-publisher-lib</filename> ) underwent
          necessary changes to communicate with the new API as well as retain full backwards
          compatibility. </para>

        <para>Beyond the structural changes a number of reported issues has been fixed and broader
          test coverage for all packages introduced. A sophisticated CI setup based on Docker has
          been created. Extensive test suite has been prepared for individual components.
          Furthermore, every API operation is independently tested against the specification, to
          assure that e.g. parameter and response types correspond exactly to the definition.</para>

        <para> Thanks to community contributions via <link xlink:show="new"
            xlink:href="https://crwd.in/tei-publisher">Crowdin</link> , TEI Publisher is now
          available in 20 languages. </para>

        <para> See chapter on <link linkend="updating">Updating</link> for information how to update
          your app to take advantage of these developments. </para>
      </section>
      <section xml:id="v6">
        <title>What's new in TEI Publisher 6.0.0</title>
        <para>Version 6 brought a major refactoring and restructuring of TEI Publisher app libraries
          along with new specialized components and use case examples.</para>
        <orderedlist>
          <listitem>
            <para> Web components overhaul: migration to <link xlink:show="new"
                xlink:href="https://lit-element.polymer-project.org/">LitElement</link> and to the
              npm library </para>
            <para>While invisible to users, this redesign greatly improves the modularity of
              Publisher-based applications. With Publisher web component releases published on npm,
              updating the user interface for all Publisher-based apps is just a question of
              changing a single variable in the configuration file.</para>
            <para> Furthermore, Publisher's library of web components - true to the basic idea of <link
                xlink:show="new"
                xlink:href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web
              Components Standard</link> can be included in any HTML webpage e.g. can be embedded
              into existing CMS or any other publishing solution, even if it's not running eXist-db. </para>
            <para> Similarly, if you prefer to write your own application using any of the popular
              frameworks like <emphasis>angular, vue or react</emphasis> you can easily import the <code>
              pb-components</code> package from npm and use it directly in your project. </para>
            <para>As a final consequence, this change decouples the component library from the TEI
              Publisher app. It is now possible to host multiple applications, which depend on
              different versions of the component library, without conflict within the same eXist-db
              instance, a point of importance for institutions with numerous projects.</para>
          </listitem>
          <listitem>
            <para>Redesigned and simplified CSS styling customization</para>
            <para> Encapsulation of styles offered by web components can be a mixed blessing and
              poses some challenges when customizing the aesthetics of components to fit a project.
              While some aspects of component styling remained unaccessible for customization in
              previous versions, Publisher 6 exposes majority of styling properties via standard CSS
              files and theme variables. Stylesheets can also be specified within the ODD, as
              previously, or through <code>pb-view</code> component configuration attributes. </para>
          </listitem>
          <listitem>
            <para>Extended internationalization</para>
            <para>I18n support has been extended to cover not only the labels in HTML templates but
              also within web components. A mechanism for project specific language files extending
              the default Publisher label collection has been added.</para>
            <para> Thanks to community contributions via <link xlink:show="new"
                xlink:href="https://crwd.in/tei-publisher">Crowdin</link> a number of new languages
              has been added and existing ones updated. </para>
          </listitem>
          <listitem>
            <para>Subcorpora - new TEI Publisher data organization</para>
            <para> Publisher's pre-populated data collection is now split into <emphasis>Playground</emphasis>
              and <emphasis>TEI Publisher demo collection</emphasis> areas which illustrate how this
              mechanism could be used to host multiple subcorpora within single TEI Publisher
              application. </para>
          </listitem>
          <listitem>
            <para>New and improved web components</para>
            <para>
              <code>pb-select-feature</code> and <code>pb-toggle-feature</code> components have been
              extended to allow for interactive changing of display parameters (like switching
              between regularized or original spelling) which can be then processed client or
              server-side. </para>
            <para>New components have been created to handle MEI music notation as well as for web
              component API documentation and demo pages.</para>
          </listitem>
          <listitem>
            <para>User interface of the ODD editor has been improved.</para>
          </listitem>
          <listitem>
            <para>Experimental incremental scroll mode has been introduced to improve performance
              for very long documents presented in single page mode.</para>
          </listitem>
        </orderedlist>
      </section>

    </section>
  </section>
  <section xml:id="quickstart">
    <title>Quickstart</title>
    <section xml:id="workshop-2020">
      <title>«Stay Home Learn TEI Publisher From Scratch»</title>
      <para> A 3-part online course has been organized by e-editiones and led by Wolfgang Meier in
        June 2020. Course material, as well as video recordings of all the sessions, and a
        walk-through for the assignments are available for self-study. Find all informations on the <link
          xlink:show="new" xlink:href="https://github.com/eeditiones/workshop#slides">workshop
        GitHub</link> page. </para>
      <mediaobject>
        <videoobject>
          <videodata fileref="https://www.youtube-nocookie.com/embed/QuWrfAS2SWM" />
        </videoobject>
      </mediaobject>
    </section>
    <section xml:id="installation">
      <title>Installation</title>
      <para> TEI Publisher requires the <link xlink:show="new" xlink:href="http://exist-db.org">eXist
        XML database</link> to operate. It is distributed as an eXist application package, making it
        easy to install on any eXist database instance - either on your local machine or any remote
        server. </para>
      <para> You can install eXist and TEI Publisher manually, as described below. Alternatively use
        the provided <link linkend="docker">docker image</link> . </para>

      <section xml:id="exist-installation">
        <title>Installing into an eXist instance</title>

        <section xml:id="java">
          <title>Java</title>
          <para> Before installing eXist, make sure you have Java installed on your machine. You can
            run <command>java -version</command> on a command line to check which version of Java
            you have. Make sure you have at least Java 8 (recommended: Java 11). Please note that
            the <command>java -version</command> shows the full version string, so 1.8.0 or similar
            instead of just 8. </para>
          <para> If you do not have Java installed, you can choose between a variety of different
            Java distributions for your operating system. While these are largely equivalent, so far
            we have had the smoothest installation experience across operating systems with the <link
              xlink:show="new"
              xlink:href="https://www.azul.com/downloads/zulu-community/?package=jdk">Zulu Community
            OpenJDK</link> builds. In particular for Windows users, this provides the best out of
            the box experience. </para>
        </section>
        <section xml:id="download">
          <title>Download</title>

          <para> Download an eXist distribution following the link on its <link xlink:show="new"
              xlink:href="http://exist-db.org/exist/apps/homepage/index.html#downloads">homepage</link>
            . </para>

          <note>
            <para>It is recommended that you set up an admin password when installing eXist but make
              sure to remember or store it securely!</para>
          </note>
        </section>

        <section xml:id="mac-installation">
          <title>Mac installation</title>
          <para> On a Mac download the file with the <command>.dmg</command> extension, e.g. " <filename>
            eXist-db-5.x.x.dmg</filename> ". </para>


          <para> Double clicking the downloaded <command>.dmg</command> file should install eXist on
            your local system. It is only required to drag the eXist app icon over to the
            Applications folder. </para>

          <para>Once the installation has completed, you should find an app in your Applications
            folder which you can use to launch eXist.</para>
        </section>

        <section xml:id="windows-installation">
          <title>Windows installation</title>
          <para> On Windows download the file with the <command>.jar</command> extension, e.g. " <filename>
            exist-installer-5.x.x.jar</filename> ". </para>

          <para> Double clicking the <command>.jar</command> should install eXist on your local
            system. It will launch an installer to guide you through basic settings. The default
            settings suggested by the installer provide a good starting point for most projects. </para>

          <note>
            <para> If double-clicking the <command>.jar</command> does not have any effect, there's
              may be something wrong with your Java setup. The <filename>java</filename> binary
              needs to be in your <envar>%PATH%</envar> environment. </para>
            <para>You can also try to manually start the installer by opening a command prompt,
              changing to the directory where you downloaded the distribution and typing:</para>
            <synopsis>java -jar exist-installer-5.x.x.jar</synopsis>
          </note>

          <para>Once the installation is completed, you should find an eXist-db shortcut to launch
            eXist.</para>
        </section>

        <section xml:id="unix-installation">
          <title>Unix installation</title>
          <para> Download the file with the <command>.jar</command> extension, e.g. " <filename>
            exist-installer-5.x.x.jar</filename> ". </para>

          <para> Double clicking the <command>.jar</command> should install eXist on your local
            system. It will launch an installer to guide you through basic settings. Default
            settings suggested by the installer provide a good starting point for most projects so
            there's no need to change anything. </para>

          <para> Once the installation is completed, you should find an eXist-db shortcut to launch
            eXist, otherwise navigate to the installation directory and run <command>bin/startup.sh</command>
            . </para>

          <note>
            <para> Some <emphasis>Linux users</emphasis> may prefer the plain <command>.tar.bz2</command>
              package, which can just be untarred to any location. This package does not include an
              installer and eXist has to be launched on the command line: navigate into the untarred
              directory and run </para>
            <synopsis>bin/startup.sh</synopsis>
            <para> in a shell, skipping the jar installer step above. Ignore the next section,
              navigate directly to <link xlink:show="new" xlink:href="http://localhost:8080">
              http://localhost:8080</link> and follow the steps for installing TEI Publisher via the
              dashboard described further below. </para>
          </note>
        </section>

        <section xml:id="first-launch">
          <title>First launch</title>
          <para>Once eXist is launched for the first time you should see (with the exception of some
            Unix system configurations described above) a splash window popping up, showing that
            default applications are being installed:</para>
          <figure>
            <title>Splash Screen on eXist Startup</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistSplash.png" width="256px" />
              </imageobject>
            </mediaobject>
          </figure>
          <para>Upon first start, an additional configuration window will pop up on Windows and Mac,
            allowing you to configure basic parameters. Default settings suggested provide a good
            starting point for most projects so usually there's no need to change anything. </para>
          <figure>
            <title>Configuration Dialog Showing on First Start</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistInitialConfig.png" width="512px" />
              </imageobject>
            </mediaobject>
          </figure>
          <para> Clicking on <guibutton>Save</guibutton> will show a popup asking to confirm the
            location of the data directory. Unless you have specific requirements just agree to the
            suggestion of the configuration dialog. </para>
          <para>
            <emphasis>Windows users</emphasis> will be asked if they would like to install eXist as
            a service. This is highly recommended to ensure that the database is correctly closed
            whenever the operating system shuts down. </para>
          <para>If all went well, eXist should now be up and running in the background. Mac and
            Windows users should find a small eXist icon in their task bar. Right-clicking on it
            will reveal a menu:</para>
          <figure>
            <title>Taskbar Launcher Context Menu</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistTaskbarIcon.png" width="512px" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section xml:id="packageManager">
          <title>Installing TEI Publisher</title>
          <para> Clicking on <guimenuitem>Open Dashboard</guimenuitem> in the taskbar will open a
            browser and display eXist's Dashboard: the central administrative hub for the database.
            Alternatively - e.g. when you chose the manual installation on Linux - you can also open
            a browser window and navigate to: <link xlink:show="new"
              xlink:href="http://localhost:8080">http://localhost:8080</link> . </para>
          <para> Log into the dashboard using the admin account and the password you chose during
            the installation (it will be empty by default). Use the left sidebar to navigate to the <guimenuitem>Package
            Manager</guimenuitem> . You'll see two tabs: the first one lists the application
            packages currently installed, the second can be used to install additional packages from
            eXist's public application repository. </para>
          <para> Switch to the <guimenuitem>Available</guimenuitem> tab and search the list for TEI
            Publisher. Once you find it, click on the little install icon. </para>
          <para>After installing you will find the TEI Publisher icon in the tab showing installed
            apps. Click on it to open the TEI Publisher.</para>
          <figure>
            <title> Installing <emphasis>TEI Publisher</emphasis> from the Package Manager </title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistDashboard.png" width="640px" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>
      </section>
      <section xml:id="docker">
        <title>Using docker</title>
        <para> If you do not want to install eXist yourself, you can use docker to run TEI
          Publisher. Docker is a tool to simplify the installation of applications and services. It
          creates a virtual environment including everything required for the service to run. Using
          our <link xlink:show="new"
            xlink:href="https://cloud.docker.com/u/existdb/repository/registry-1.docker.io/existdb/tei-publisher">docker
          image</link> , eXist will already be set up to include TEI Publisher as well as the
          Shakespeare and Van Gogh demo apps. </para>
        <procedure>
          <step>
            <para> Install <link xlink:show="new" xlink:href="https://www.docker.com/">docker</link>
              on your machine. Windows and Mac users may download the <link xlink:show="new"
                xlink:href="https://www.docker.com/products/docker-desktop">docker desktop</link>
              app. </para>
          </step>
          <step>
            <para>To download the image run the following in a console</para>
            <synopsis>docker pull existdb/teipublisher:latest</synopsis>
          </step>
          <step>
            <para>once the download is complete, you can run the image with the following command:</para>
            <synopsis>docker run -p 8081:8080 -p 8444:8443 --name teipublisher existdb/teipublisher:latest</synopsis>
            <para>Startup should be fast because the database is already pre-populated. However,
              changes you make may not persist if the docker container is deleted or updated to a
              newer release. If you want to be sure that your changes are safe, you should specify a
              local volume for storing the database by adding:</para>
            <synopsis>-v exist-data:/exist-data</synopsis>
            <para>See below for an explanation of the parameters:</para>
            <variablelist>
              <varlistentry>
                <term>-p</term>
                <listitem>
                  <para>Maps a port on your local machine (8081 and 8444) to the port used by eXist
                    within the container. eXist will always run on 8080 for HTTP and 8443 for HTTPS.
                    If those ports are already occupied by different services on your machine,
                    choose a different port for the first number.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>-v</term>
                <listitem>
                  <para> Creates a named ("exist-data") volume for storing the database, using the
                    directory specified after the colon. If you skip this, any changes to the
                    database will be lost if you remove the docker container, update it or create a
                    new one. With <option>-v</option> the data will be stored outside the container. </para>
                  <para>If you just intend to play around a bit, you can skip the parameter.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>--name</term>
                <listitem>
                  <para> Assigns a name to the container, so you can reference it in other docker
                    commands, like <code>docker stop</code> . We'll use the name in all commands
                    below. </para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>Once the container has started, you can access the eXist dashboard in your browser
              by navigating to</para>
            <synopsis>http://localhost:8081</synopsis>
            <para>From the dashboard you can click on the TEI Publisher, Shakespeare or Van Gogh
              icons to open the corresponding applications.</para>
          </step>
          <step>
            <para>To stop the container run</para>
            <synopsis>docker stop teipublisher</synopsis>
          </step>
          <step>
            <para>To start the container again:</para>
            <synopsis>docker start teipublisher</synopsis>
            <para>Note that when you restart a container, it will run in detached mode, so you won't
              see any console output. You can view the output with following command though:</para>
            <synopsis>docker logs teipublisher</synopsis>
          </step>
        </procedure>
        <section xml:id="docker-other">
          <title>Other useful commands</title>
          <variablelist>
            <varlistentry>
              <term>docker container ps -a</term>
              <listitem>
                <para>Lists all running and stopped containers</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>docker volume ls</term>
              <listitem>
                <para>Displays existing volumes (where your database is stored)</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>docker cp teipublisher:/exist-data .</term>
              <listitem>
                <para>Copy the contents of the database data volume to the current directory on
                  local disk, so you can back it up. Note that this will copy the raw database files
                  as created by eXist (not your XML, which is binary encoded inside those files).
                  Also make sure you run the command after stopping the active container.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>docker volume rm exist-data</term>
              <listitem>
                <para>Remove the contents of the database data volume (in case you would like to
                  start from scratch, deleting all changes you made).</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para> Have a look at the docker documentation and <link xlink:show="new"
              xlink:href="https://www.docker.com/sites/default/files/Docker_CheatSheet_08.09.2016_0.pdf">
            cheatsheet</link> for more commands. </para>
        </section>
      </section>
    </section>
    <section xml:id="browsing">
      <title>Browsing Documents</title>
      <section xml:id="start-page">
        <title>The Start Page</title>
        <para>The start page of TEI Publisher serves as an entry point to explore and experiment.</para>
        <para>On a newly installed TEI Publisher the main application panel offers the choice
          between browsing local collections directly or using DTS API to access remote resources.
          Narrower panel to the right displays the list of ODD files provided with the TEI
          Publisher.</para>

        <figure>
          <title>Start Page Collections</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="start-page-collections.png" width="512px" />
            </imageobject>
          </mediaobject>
        </figure>
        <para> The usual starting point is the <emphasis role="bold">TEI Publisher Demo Collection</emphasis>
          with which users can explore a range of <link linkend="selected-use-cases">selected use
          cases</link> , demonstrating various genres, encoding styles and presentation layouts.
          Various customization aspects are handled using different ODDs and view templates. We
          suggest to have a look at each of them to see what TEI Publisher can achieve out of the
          box. </para>

        <note>
          <title>Note</title>
          <para>Documents in this collection are preinstalled with the TEI Publisher and users are
            not allowed to write to it by default.</para>
        </note>

        <para> The <emphasis role="bold">Playground</emphasis> collection is the place to upload
          encoded documents and ODD files to experiment with various processing models and view
          templates. </para>

        <para> Unlike the Demo collection, the Playground features an upload box to import new
          documents. You can upload your own XML and ODD (e.g. TEI, DocBook or DOCX) documents by
          either clicking on the <code>Upload</code> button or dragging and dropping files onto the
          upload panel. Read more on this subject in the <link linkend="upload">Upload</link>
          section </para>
        <note>
          <title>Note</title>
          <para> You need to be <emphasis role="bold">logged in</emphasis> for most advanced actions
            like creating or editing ODDs. The login button to the right of the menu bar allows you
            to log in. By default, there's a user named <parameter>tei-demo</parameter> with
            password <parameter>demo</parameter> , and a user <parameter>tei</parameter> with
            password <parameter>simple</parameter> . </para>
        </note>
      </section>
      <section xml:id="demo-collection">
        <title>TEI Publisher Demo collection</title>
        <para> Experiment with browsing, faceting, filtering and sorting features of TEI Publisher.
          This page consists of several main areas: <orderedlist>
            <listitem>
              <para>the facets panel</para>
            </listitem>
            <listitem>
              <para>the list of documents currently installed with sorting and filtering controls</para>
            </listitem>
            <listitem>
              <para>a panel showing the ODD files known to the application</para>
            </listitem>
            <listitem>
              <para>an upload box to upload new documents</para>
            </listitem>
          </orderedlist>
        </para>

        <para>Have a look at documents showcased here to get a sense of possibilities that TEI
          Publisher offers. Click on document title to proceed to the Document View</para>
        <figure>
          <title>Browsing Demo collection</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="demo-collection-overview.png" width="512px" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section xml:id="selected-use-cases">
      <title>Selected Use Cases</title>
      <para>The document view can vary, sometimes substantially, depending on the sample document
        you are looking at. This is a natural consequence of TEI's versatility and broad scope of
        its application. What follows, requirements for the document view - both its layout and
        composition as well as processing rules governing the transformation of the text of the
        document itself - will differ to a great extent. Sample documents which are included in TEI
        Publisher's installation package do not exhaust its applications but rather aim to present
        some chosen use cases:</para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis>Critik der reinen Vernunft</emphasis> from the <emphasis>Deutsches Textarchiv</emphasis>
            corpus presents a philosophical tractate, originally published in print, thus following
            'traditional' book structure with front pages, foreword and chapters. It can
            nevertheless demonstrate very well Publisher's capacities in typesetting, switching
            between physical and logical structure of the document (just toggle <guibutton>Page View</guibutton>
            in the <guibutton>Settings</guibutton> panel) as well as generation of multiple output
            formats from single set of processing models in the ODD (try choosing <parameter>PDF</parameter>
            or <parameter>ePub</parameter> options in the <guibutton>Download</guibutton> ). <emphasis>Purchas
            his pilgrimages</emphasis> , from the <emphasis>EEBO-TCP</emphasis> project, while
            roughly similar in structure is much earlier work (1613) and demonstrates extensive use
            of marginal notes. </para>
        </listitem>
        <listitem>
          <para> Shakespeare's <emphasis>Romeo and Juliet</emphasis> , from <emphasis>Bodleian First
            Folio</emphasis> project uses dedicated TEI elements to encode structure of the play but
            it also showcases the parallel transcription and facsimile alignment for its
            presentation which is obviously of general application and could be used for any genre,
            not limited to dramatic texts. </para>
        </listitem>
        <listitem>
          <para>Correspondence corpora are common, yet very interesting, subjects for digital
            editions. Despite basic similarities in structure, depending on the period, scope and
            particular research perspective, intended presentation may vary enormously. We are
            presenting samples of:</para>
          <itemizedlist>
            <listitem>
              <para> A 15th century manuscript letter to <emphasis role="bold">Mikołaj Orlik</emphasis>
                demonstrating alignment between Latin original and parallel Polish translation, </para>
            </listitem>
            <listitem>
              <para> A 16th century manuscript letter of <emphasis role="bold">Hernán Cortés</emphasis>
                showcasing parallel transcription/translation and facsimile view and transcription
                enhanced with commentaries and explicitly encoded transcriptional features, </para>
            </listitem>
            <listitem>
              <para> A 16th century manuscript letter of <emphasis role="bold">Mauritius Ferber</emphasis>
                with a collapsible metadata panel in addition to the parallel transcription and
                facsimile view, </para>
            </listitem>
            <listitem>
              <para> An early 19th century manuscript collocative dictionary of Polish <emphasis
                  role="bold">Bogactwa mowy polskiej</emphasis> featuring interactive highlights for
                regions of interest of the facsimile when hovering over dictionary headwords, </para>
            </listitem>
            <listitem>
              <para> A letter from <emphasis role="bold">Van Gogh</emphasis> to Paul Gauguin written
                in 1888. This intentionally reproduces the flexible column layout pioneered by the <link
                  xlink:show="new" xlink:href="http://vangoghletters.org">Vincent Van Gogh Letters</link>
                online edition, which is a model example for correspondence. </para>
            </listitem>
            <listitem>
              <para> A 20th century manuscript letter from <emphasis>Robert Graves</emphasis> where
                emphasis has been put on visualizing rich encoding of semantic information in the
                letter, in particular geographic and prosopographical data. </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
      <note>
        <title>Note</title>
        <para>The list of samples is expected to grow and we'd like to encourage contributions
          illustrating other genres and perspectives.</para>
        <para> We'd like to stress that preparing showcases above has been only possible thanks to
          numerous projects releasing their sources openly, in particular the <link xlink:show="new"
            xlink:href="http://firstfolio.bodleian.ox.ac.uk">Bodleian First Folio</link> , <link
            xlink:show="new" xlink:href="http://www.deutschestextarchiv.de">Deutsches Textarchiv</link>
          , <link xlink:show="new" xlink:href="http://vangoghletters.org">Vincent Van Gogh Museum</link>
          and <link xlink:show="new" xlink:href="https://www.textcreationpartnership.org/tcp-eebo">
          EEBO-TCP</link> . We'd also like to thank William Graves and Anna Skolimowska for sharing
          their correspondence material. </para>
      </note>
    </section>

    <section xml:id="document-view">
      <title>Document View</title>
      <para>The document view can vary, depending on the sample document you are looking at.
        Nevertheless some default functionality will be shared:</para>
      <itemizedlist>
        <listitem>
          <para> the rightmost button in the toolbar opens the <guibutton>Settings</guibutton>
            panel. Here you can change the ODD being used for display as well as the view template
            (more about this later). By default, all sample documents apply the specific ODD which
            fits them best, but you can play around and select another ODD to see what happens. </para>
          <figure>
            <title>The Settings Panel</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="odd-page-template-settings.png" width="512px" />
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>
        <listitem>
          <para> the leftmost toolbar button will open a <emphasis>table of contents</emphasis> (if
            the viewed document has a division structure) </para>
        </listitem>
        <listitem>
          <para> the <guibutton>Download</guibutton> menu allows you to download the currently
            viewed document in a variety of output formats. Not all output formats work equally well
            for all examples as we have not customized every example for every media. </para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="odd-experiments">
      <title>Experimenting with ODDs and page templates</title>
      <para> All TEI Publisher's sample documents are TEI XML files which are transformed into a
        HTML webpage for display in the browser. Two major factors determine how the final page is
        going to look like: an <emphasis role="bold">ODD</emphasis> and a <emphasis role="bold">page
        template</emphasis> . </para>

      <para> We have already mentioned in the very first section that the TEI Processing Model lies
        at the heart of the Publisher - the ODD file associated with a document defines the rules of
        transformation of the XML source file into HTML. Detailed discussion of the Processing Model
        can be found in <link linkend="pm-syntax">following chapters</link> , for now it is
        sufficient to say this is where decisions if a TEI element should be rendered inline, with a
        tooltip, or as a marginal note, are made. Simplifying things a bit the <emphasis>text</emphasis>
        of the document that you see rendered in your browser is an effect of applying the rules
        from ODD file to the source document. </para>
      <para> Nevertheless, as we demonstrated in the section on selected sample documents, in the
        application context we certainly want more than just text, however nicely typeset. From
        basic navigation controls, table of content, to facsimile display, critical apparatus,
        glossaries and maps - all of this and much more could be included in the final webpage.
        Following <emphasis>divide and conquer</emphasis> approach the TEI Publisher defines such
        specialized page elements as small, reusable blocks, using the Web Components technology.
        Components can be used like common HTML elements, thus a page template is just an HTML
        fragment which organizes the building blocks needed for a specific page. </para>
      <para> Looking more closely again at the TEI Publisher's <guibutton>Start</guibutton> page, we
        can now give more detail what is happening when any of the sample documents is loaded. On
        the right hand side there is a panel listing all ODD files available. Each of the sample
        documents includes a processing instruction which specifies default ODD and page template
        for this document. You can check what they are in <guibutton>Settings</guibutton> panel. For
        the Graves letter it would be <parameter>Graves' Letters</parameter> ODD and <parameter>Letter
        with map/facets</parameter> template. </para>
      <figure>
        <title>The Settings Panel for the Graves Letter</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="odd-page-template-settings.png" width="512px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> It is easy to experiment with different page templates and ODDs just changing these
        options in the <guibutton>Settings</guibutton> panel. An important caveat though is that not
        every page template makes sense for every document - after all parallel alignment can only
        be successful if there is something to align, map needs coordinates to display, page view
        needs information about page breaks and so on. </para>
    </section>
    <section xml:id="upload">
      <title>Uploading your own documents</title>
      <para> If you read this, in all likelihood you already have some documents of your own you
        might want published, whether they are in TEI, DocBook, MS Word DOCX or other XML format.
        The first step is to upload them into the database. You need to be <emphasis role="bold">logged
        in</emphasis> and in the Playground area to do it (check the short info on the <guibutton>
        Start</guibutton> page for user name and password). Then uploading is just a question of
        dragging your documents onto the <guibutton>Upload</guibutton> area. They will become
        available in the document list immediately after upload is completed. </para>
      <figure>
        <title>The Upload Panel</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="upload.png" width="512px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> Congratulations, now you can view your documents! Try to experiment and find the ODD
        and page template that best fits your needs and use it as a starting point for your own
        customization, if necessary. Once you are ready with these you can <link
          linkend="create-app">generate your own application</link> for your documents only, which
        packs just what is needed for publishing into a standalone application package. </para>
      <para> If you attempt to upload a Microsoft Word document, the upload will automatically
        trigger upconversion of Word to TEI, using a custom ODD for the tranformation. Please note
        that the focus of this conversion is to preserve textual content, structure and basic
        semantics of the text, not provide authoritative mapping of complete set of MS Word features
        to TEI. Refer to <link linkend="docx">DOCX handling</link> section for more information. </para>
      <note>
        <title>Note</title>
        <para>Please bear in mind that while TEI Publisher aims to be a universal tool, the specific
          components may make certain assumptions about data they are getting and if your documents
          do not follow the same conventions it may be required to adjust parameters passed to the
          components from the page template or the component logic.</para>
        <para> By means of example - a table of content component assumes that the document
          structure is represented by means of nested <parameter>div</parameter> elements and
          section titles are given in <parameter>head</parameter> element. If your project rather
          chooses numbered divisions ( <parameter>div1</parameter> , <parameter>div2</parameter> )
          etc it may be advisable to adjust this to avoid customizing all navigation, table of
          contents and so on, but it is one of very rare cases where TEI Publisher exposes any
          predilection for a particular flavour of TEI. </para>
        <para> Similarly, the template for aligned transcription and translation is parametrized to
          accept an XPath expression pointing to the location of the transcription and aligned
          translation. Likely for your documents this expression would have to be adjusted (unless
          of course you also have Latin texts with Polish translation structured in a similar way).
          Furthermore, to correctly display corresponding translation fragment a custom mapping
          function may need to be passed to the translation view (cf. <link
            xlink:href="templates/pages/vangogh.html" role="source">
            <filename>Van Gogh</filename>
          </link> or <link
            xlink:href="templates/pages/cortez.html" role="source">
            <filename>Cortés</filename>
          </link> letter templates for examples) </para>
      </note>
    </section>
  </section>

  <section xml:id="supported-input-formats">
    <title>Supported XML vocabularies</title>
    <para>TEI Publisher started as a publishing toolbox for TEI but the principles of TEI Processing
      Model were never limited to a single vocabulary. Publisher very quickly extended support to
      other XML formats. Currently TEI, DocBook, JATS and MS Word DOCX are supported out of the box
      (DOCX via automated conversion to TEI on upload).</para>
    <para> Few specificities of <emphasis>TEI</emphasis> and <emphasis>DocBook</emphasis> are listed
      below, while <emphasis>DOCX</emphasis> is discussed at length in the following section. </para>
    <para />
    <section xml:id="format-tei">
      <title>TEI</title>
      <para>In principle, any TEI document will be supported by TEI Publisher and can be displayed
        with the default page template and odd.</para>
      <para>Nevertheless, certain assumptions are made about encoding of the basic structure of the
        TEI documents for the purpose of navigation:</para>
      <itemizedlist>
        <listitem>
          <para> page beginnings are encoded with <tag>pb</tag>
          </para>
        </listitem>
        <listitem>
          <para> column beginnings are encoded with <tag>cb</tag>
          </para>
        </listitem>
        <listitem>
          <para> structural divisions in the document are encoded with <tag>div</tag> elements </para>
        </listitem>
      </itemizedlist>
      <para> We acknowledge that TEI offers other ways to encode these features, e.g. generic <tag>
        milestone</tag> element or specialized numbered division elements like <tag>div1</tag> , <tag>
        div2</tag> . TEI documents using alternative encodings will be still displayed as specified
        in the ODD, it is only for the sake of navigation or division-based full text search that we
        had to assume certain conventions to be able to decide what to show as the next page, column
        or division. </para>
      <para> We believe our choice represents most common way of using TEI but, for those who
        followed the path less travelled, the chapter on <link linkend="new-vocabulary-navigation">
        customization</link> briefly discusses how to change relevant functionality. </para>
    </section>

    <section xml:id="format-docbook">
      <title>DocBook</title>
      <para> DocBook support is demonstrated by this very document you are now reading, <filename>
        documentation.xml</filename> . It is written in DocBook and presented via dedicated <filename>
        docbook.odd</filename> and <filename>documentation.html</filename> page template. </para>
      <para> You will notice a custom processing instruction in the source code of this document
        which specifies which ODD and template to use. Experiment changing the template and ODD via <guibutton>
        Settings</guibutton> drawer to see how much impact it has on display. </para>
      <programlisting language="xml" xml:space="preserve">
          &lt;?teipublisher odd="docbook.odd" template="documentation.html" depth="3"?&gt;
        </programlisting>
    </section>


    <section xml:id="docx">
      <title>MS Word DOCX format conversion</title>
      <para> Starting with the version 5.0.0 of the TEI Publisher a new docx handling module is
        available to allow for ingesting documents in <emphasis>docx</emphasis> format. Goal of this
        module is to provide a way to import Word documents, preserving their textual content,
        structure and basic semantics of the text, not to provide an authoritative mapping of
        complete set of MS Word features to TEI. </para>
      <para>Docx format is relatively flat, thus reconstructing logical document structure like
        divisions, lists and similar can be only based on certain heuristics. Likewise it is
        impossible to deduce semantics attributed to certain formatting decisions. For that reason
        TEI Publisher by intention ignores many style properties — trying to preserve as much as
        possible would likely just add unnecessary "noise" and result in low-quality TEI. </para>


      <section xml:id="docx-intro">
        <title>A word about Word</title>

        <para> A Word document is essentially a zip archive of several different XML files. These
          files store various parts - the text content, styles, embedded media files etc.
          Information most relevant for the import process have been extracted into a map, which is
          passed as a parameter to the ODD, so it is available for every element. Thus information
          about numbering styles can be accessed via <code>$parameters?nstyle(.)</code> function and
          testing if a list is bulleted could be done checking the value of <code>
          $parameters?nstyle(.)/numFmt/@w:val</code> . Full list of available functions and some
          hints how to customize default conversion ODD are provided at the <link
            linkend="docx-functions">end of this chapter</link> . </para>
        <figure>
          <title>MS Word archive structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="wordStructure.png" width="212px" />
            </imageobject>
          </mediaobject>
        </figure>

        <variablelist>
          <varlistentry>
            <term>Named tei:* styles</term>
            <listitem>
              <para> Named styles can be strong indicators for the semantics of the text fragment.
                Styles whose name starts with <code>tei:</code> are thus recognized as TEI elements
                with the same name. If a character sequence uses a style called <code>tei:persName</code>
                , it will be wrapped into a TEI <tag>persName</tag> element in the output, e.g. <code>&lt;persName&gt;Johann
                Wolfgang Goethe&lt;/persName&gt;</code> . A place name should be marked with a style <code>
                tei:placeName</code> and reconstructed text could be encoded by applying a style <code>
                tei:supplied</code> . </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Headings and divisions</term>
            <listitem>
              <para> Since Word does not have a concept for text division, instead storing just flat
                lists of paragraphs, so the only way to reconstruct the logical structure is to use
                Word headings and outline level associated with these to determine division
                boundaries. </para>
              <para> In the first pass, all paragraph styles starting with <code>heading</code> , <code>
                title</code> or <code>subtitle</code> generate a <tag>tei:head</tag> element. The
                outline level assigned to the heading is recorded as well. </para>
              <para> Subsequently, in a second pass through the generated output, divisions are
                generated based on the outline level: a <tag>div</tag> spans all text from the
                heading to the next heading on the same outline level and the process is repeated
                for all headings within the division on a lower outline level. </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Lists</term>
            <listitem>
              <para> Lists structure needs to be reconstructed, very much like divisions, taking
                into consideration the list level associated with every item which can be accessed
                via a call to <code>$parameters?pstyle(.)//outlineLvl/@w:val</code> . </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> Foot- and endnotes</term>
            <listitem>
              <para> Footnotes are translated into TEI note elements. Endnotes are also supported
                and transformed into <code>&lt;note type="endnote"&gt;</code> . </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Tables</term>
            <listitem>
              <para> Processing of simple tables works very well as well as cells spanning multiple
                colums. Row spans are not implemented yet. </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Images</term>
            <listitem>
              <para> Embedded images are stored into a subcollection starting with the name of the
                docx file being processed and suffixed with <code>.media</code> , eg. <code>&lt;graphic
                url="test.docx.media/image1.png"/&gt;</code>
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section xml:id="docx-functions">
        <title>ODD for docx</title>
        <para> The ODD used for docx processing can be found in <link xlink:href="odd/docx.odd"
            role="source">docx.odd</link> . Users are free to extend the default ODD with additional
          heuristics. For example, a paragraph being entirely bold could also be treated as a
          heading, or a left text indent may indicate a quote. </para>
        <para> For testing purposes there is a Word document provided in <filename>
          data/doc/test.docx</filename> which includes samples of most important features like
          headings, lists, tables, notes and embedded images. Try uploading it via upload panel as
          described in the <link linkend="upload">upload section</link> and check the conversion
          results. Behaviour of the conversion mostly follows the approach used in TEI Stylesheets
          docx-to-tei transformation module and has been tested on test files included there. </para>

        <section xml:id="docx-functions-parameters">
          <title>Parameter functions</title>
          <para> Functions below can be used to retrieve styles or other information related to a
            current node. For more usage examples see <link xlink:href="odd/docx.odd" role="source">
            docx.odd</link>
          </para>

          <variablelist>
            <varlistentry>
              <term>cstyle</term>
              <listitem>
                <para>phrase level (characters, words or phrases) styles associated with the current
                  node</para>
                <para> Returns: <code>w:style</code>
                </para>
                <para> Usage example: <code>$parameters?cstyle(.)/name[starts-with(@w:val, 'tei:')]</code>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>endnote</term>
              <listitem>
                <para>content of the endnote</para>
                <para> Returns: <code>w:endnote/w:p</code>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>footnote</term>
              <listitem>
                <para>content of the footnote</para>
                <para> Returns: <code>w:footnote/w:p</code>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>link</term>
              <listitem>
                <para>external link</para>
                <para> Returns: <code>rel:Relationship</code>
                </para>
                <para> Usage example: <code>$parameters?link(.)/@Target</code>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>nstyle</term>
              <listitem>
                <para>list style information associated with the current node</para>
                <para> Returns: <code>w:lvl</code>
                </para>
                <para> Usage example: <code>$parameters?nstyle(.)/numFmt</code>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>pstyle</term>
              <listitem>
                <para>paragraph level styles associated with the current node</para>
                <para> Returns: <code>w:style</code>
                </para>
                <para> Usage example: <code>$parameters?pstyle(.)/name[matches(@w:val, 'quote';,
                  'i')]</code>
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
    </section>
  </section>
  <section xml:id="odd-customization">
    <title>Processing Model transformations</title>
    <para>While TEI Publisher already provides various ODDs and page templates targeting specific
      domains, it is likely that your project may require certain adjustments to fully meet your
      needs. It has been one of primary concerns in Publisher's design that customization is not
      only possible on various levels but also encouraged and we aim it to be as simple as possible.</para>
    <para> Very broadly we can group customization needs into two sets: changing the rules for
      document transformation (how the source document is translated into the output format) or
      changing the organization and styling of the rendered web page. In this chapter we'll
      concentrate on the former, document transformation, which primarily requires modification of
      the ODD with the <link linkend="pm-syntax">TEI Processing Model</link> . The latter would
      require <link linkend="customizing-page-template">adjustments of the page template</link> . In
      both cases, it may be best to choose as your starting point an already existing ODD or page
      template and adjust it. </para>
    <section xml:id="odd-customization-details">
      <title>ODD Customization</title>
      <section xml:id="odd-customization-first-odd">
        <title>Creating Your First ODD</title>
        <para> The general workflow for creating a customization is as follows: <orderedlist>
            <listitem>
              <para>upload a TEI sample document you want to format</para>
            </listitem>
            <listitem>
              <para>create a new ODD</para>
            </listitem>
            <listitem>
              <para>modify the ODD to match your requirements</para>
            </listitem>
          </orderedlist>
        </para>
        <para> For the purpose of this quickstart, we will reuse one of the pre-installed sample
          documents, but create a new ODD for it (while we will start from scratch with an empty
          ODD, it is also possible to generate one based on one or more <link
            linkend="odd-by-example">sample TEI documents</link> ): </para>
        <procedure>
          <step>
            <para> Log in and fill out the form at the bottom of the panel listing ODD files. Choose
              a name for the ODD, e.g. <option>myletter</option> (without a suffix) and a title,
              which will appear in the list after creation. Click on <guibutton>Create</guibutton>
              (not <guibutton>Create from examples</guibutton> ). </para>
            <para>The newly created ODD should appear in the side panel.</para>
          </step>
          <step>
            <para> In the document list, click on <emphasis>Letter #6 from Robert Graves to William
              Graves</emphasis> to open it in the document viewer. </para>
          </step>
          <step>
            <para> Open the <guibutton>Settings</guibutton> panel (rightmost toolbar button, see
              above) and choose your ODD from the dropdown showing available ODDs. You may also
              change the used HTML template to <option>Default single text layout</option> , though
              this is not absolutely necessary. </para>
          </step>
          <step>
            <para> The view should change and display the letter's content with only basic
              formatting applied. Since our ODD has just been created and is empty, we see the
              content with standard formatting applied. Our ODD by default inherits from <filename>
              teipublisher.odd</filename> , which likewise extends <filename>tei_simplePrint.odd</filename>
              . The latter is maintained by the TEI community and contains processing model
              declarations for the most important TEI elements. Thanks to this inheritance
              mechanism, many documents display nicely without requiring a lot of additional
              customization. </para>
          </step>
          <step>
            <para> From the menu, select <guimenu>Admin</guimenu> / <guimenuitem>Edit ODD</guimenuitem>
              to open the visual ODD editor. </para>
          </step>
        </procedure>
      </section>
      <section xml:id="modify-odd">
        <title>Modify the ODD</title>
        <para> Changing processing models in the ODD is a powerful mechanism through which you can
          control all aspects of the transformation of your documents from source XML format to all
          output formats: HTML, ePUB, PDF etc. As already mentioned it is considered best practice
          to chain ODD customizations together and rather change or add project specific rules to
          more generic ODD than copy them in extenso. ODD chaining allows for the future upgrades as
          your base ODDs may be updated by standardization bodies which maintain them. Commonly
          project ODDs would extend <filename>teipublisher.odd</filename> , a generic TEI Publisher
          set of processing rules. </para>
        <para>Beginning with version 3.0 of TEI Publisher, you have the choice between writing the
          ODD by hand or using a visual editor. Both approaches can be combined and mixed. The
          visual editor saves the ODD in a non-destructive way, preserving any information not
          related to the processing model. It is thus safe to switch between hand-editing the ODD
          and using the visual editor. Just make sure you reload the visual editor view after
          modifying the source XML and vice versa. That said, visual editor is specifically tailored
          to editing processing models so it will be likely the fastest and safest way to edit your
          ODD.</para>
        <para>To be able to customize the display of your document it is crucial to understand its
          XML structure well. Each of processing models needs to be aimed at a particular XML
          element and sometimes is only meant for a specific XML context - let's say we might want
          to distinguish between headings of first and second level of nested divisions as they
          often represent titles of different text units: acts and scenes or books and chapters.</para>
        <para>We'll start with the Graves' letter you have already viewed applying your custom ODD
          in previous section. The display is quite simple and easy to read but we might want to
          adjust it to follow common visual conventions for a letter, starting with displaying the
          dateline on the right hand side and completely removing the page label which currently
          sits there.</para>
        <para> To create a processing model addressing this need we have to know 3 things: </para>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="bold">when</emphasis> should it be applied, </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">what</emphasis> is supposed to happen </para>
          </listitem>
          <listitem>
            <para> and <emphasis role="bold">how</emphasis> should the text be formatted? </para>
          </listitem>
        </itemizedlist>
        <para> To be able to answer the first question, you should familiarize yourself with the XML
          structure of the letter to find out how datelines are represented in TEI. In the tab
          displaying the letter, select <guimenuitem>Download</guimenuitem> / <guimenuitem>XML </guimenuitem>
          to open <link xlink:href="data/test/graves6.xml" role="source">
            <filename>graves6.xml</filename>
          </link> in eXide. Quick investigation of the
          TEI encoding will reveal that dateline resides in its eponymic tag <tag>dateline</tag>
          wchich is nested in the <tag>opener</tag> part of the document, while page labels are
          encoded with <tag>pb</tag> . </para>
        <para> We'll use the visual editor, but show the corresponding ODD XML below each
          screenshot. At the end of this chapter we'll describe how to edit the ODD XML code <link
            linkend="oddxml">by hand</link> . </para>
      </section>

      <section xml:id="visualodd">
        <title>First Steps</title>
        <para> The visual ODD editor opens if you select <guimenuitem>Admin</guimenuitem> / <guimenuitem>Edit
          ODD</guimenuitem> from the menu while viewing a document. Alternatively you can click on
          the name of an ODD in the list of ODDs on the TEI Publisher entry page. A new tab opens,
          showing an action panel to the left, and the title of your ODD to the right. </para>
        <note>
          <title>Note</title>
          <para>
            <emphasis>Most recent versions of the ODD editor will look slightly different,
            nevertheless they are functionally equivalent to the screenshots below, created in an
            earlier version.</emphasis>
          </para>
        </note>
        <para> We need to overwrite the processing model rules for <tag>dateline</tag> . Enter <parameter>
          dateline</parameter> into the input box next to the <guibutton>New</guibutton> button in
          the left panel and click the button. This will insert a processing model rule for <tag>
          dateline</tag> into the right panel. Because <tag>dateline</tag> already exist in the base
          ODD, <filename>tei_simplePrint.odd</filename> , you'll see a single model which was copied
          from the base ODD. </para>
        <figure>
          <title> Screen after adding <tag>dateline</tag>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen1.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <para>The corresponding ODD XML looks like this:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="dateline"&gt;
    &lt;model behaviour="block"/&gt;
&lt;/elementSpec&gt;</programlisting>
        <para> Let's cover some key concepts of the TEI processing model first: <tag>elementSpec</tag>
          primarily documents the structure, content, and purpose of an element. It is a core
          element in any ODD but the schema-related functions are not relevant for the discussion
          here. What is important for us is this is where processing models are defined. The <parameter>
          @ident</parameter> attribute of the <tag>elementSpec</tag> identifies the name of the
          element to which the spec (and therefore processing model) applies. </para>
        <para> An <tag>elementSpec</tag> may contain one or more <tag>model</tag> elements to
          specify the intended processing of this element. Every model maps the element to a <option>
          behaviour</option> . A behaviour denotes an abstract transformation function to be
          applied. The TEI guidelines currently list two dozen behaviours, e.g. paragraph, heading,
          note, inline, block. The last two are the most frequently used. How exactly a behaviour
          translates into the target output media may differ depending on media features and design
          decisions. TEI Publisher tries to implement them as generically as possible. </para>
        <para> To change the model expand it by clicking on the arrow to the left of the grey box. A
          form appears, allowing you to change the model configuration. In our example we are happy
          with <emphasis>what</emphasis> is happening with the dateline, so we don't need to change
          the behaviour but we do want to fix <emphasis>how</emphasis> it is styled by justifying it
          to the right. Rendition can be defined in an <tag>outputRendition</tag> , so click on the <guibutton>
          +</guibutton> button next to <guibutton>Renditions</guibutton> . In the form input being
          inserted below, enter your styling requirements in css. </para>
        <para> The processing model uses <tag>outputRendition</tag> and CSS to define visual
          aspects. For output formats other than XML, the CSS is translated into the corresponding
          target language. It is thus best to limit the CSS to the most common typographical
          features, like bold, italic, color, underline etc. The general styling of the text should
          be done outside the ODD to maintain a clear separation of concerns. </para>
        <figure>
          <title> Add a rendition for <tag>dateline</tag>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen2.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <para>Again here's the corresponding XML:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="dateline"&gt;
  &lt;model behaviour="block"&gt;
      &lt;outputRendition&gt;text-align: right;&lt;/outputRendition&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <para> To test your change, click on <guibutton>Save</guibutton> in the left panel and wait
          a second until a popup appears. Switch back to the tab with Graves' letter from which you
          opened the editor and refresh the browser window to see your changes applied. In case you
          do not see any change, make sure </para>
        <orderedlist>
          <listitem>
            <para> you selected the correct ODD for viewing (check the <guibutton>Settings</guibutton>
              drawer) </para>
          </listitem>
          <listitem>
            <para> if you made changes to outputRenditions only, you may need to clear your
              browser's cached version. For most browsers, holding the <emphasis>Shift</emphasis>
              key while clicking on the <emphasis>Reload</emphasis> button does the job. </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="odd-customization-other-behaviours">
        <title>Other behaviours</title>
        <para> We would also like to hide the page breaks as we do not have facsimiles available.
          Add a new element spec for <tag>pb</tag> . Again the newly added spec already includes a
          model with behaviour <option>break</option> . Just change this behaviour to <option>omit</option>
          or delete the existing model and insert a fresh one with behaviour <option>omit</option> . </para>
        <figure>
          <title> Omit <tag>pb</tag>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen3.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="pb"&gt;
  &lt;model behaviour="omit"/&gt;
&lt;/elementSpec&gt;</programlisting>
      </section>
      <section xml:id="odd-customization-predicates">
        <title>Predicates and multiple models</title>
        <para> Next up, we may want to highlight the various places and people occurring within the
          text. They are all marked up with the <tag>name</tag> tag, using different <option>@type</option>
          attributes. Create a new element spec for <tag>name</tag> and supply some color to the
          names. </para>
        <figure>
          <title> Color the <tag>name</tag> tags </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen4.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <para> And the XML for the entire <tag>elementSpec</tag> : </para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="name" mode="change"&gt;
    &lt;model behaviour="inline"&gt;
        &lt;outputRendition&gt;
        color: #FF9900;
        &lt;/outputRendition&gt;
    &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <para> This rule affects places and people alike since both these categories are marked up
          with <tag>name</tag> tag. If we'd like to treat people and places differently we'd need
          separate models for them and a mechanism to distinguish between the two. The processing
          model uses <option>predicate</option> to make such distinctions: a model rule will only be
          used if the XPath expression in its predicate matches the current node being processed.
          Let's add another model and give it a predicate: </para>
        <figure>
          <title>Distinguish places and people</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen5.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="name" mode="change"&gt;
    &lt;model predicate="@type='place'" behaviour="inline"&gt;
        &lt;outputRendition &gt;
        color: #0077FF;
        &lt;/outputRendition&gt;
    &lt;/model&gt;
    &lt;model behaviour="inline"&gt;
        &lt;outputRendition&gt;
        color: #FF9900;
        &lt;/outputRendition&gt;
    &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <note>
          <title>Important</title>
          <para>The order of models within the element spec is important. If you move the model with
            the predicate to the bottom, all names will appear in the same color again. This happens
            because the processor walks through the models until it finds the first one matching the
            current node. If the model without predicate is first, it will always win over the one
            with the predicate!</para>
          <para>Also, if there's more than one matching model, only the first will be chosen.</para>
        </note>
      </section>
      <section xml:id="odd-customization-parameters">
        <title>Parameters</title>
        <para> All behaviours accept one or more parameters which are defined in the TEI guidelines.
          Every behaviour has an implicit parameter called <parameter>content</parameter> , and, as
          the name suggests, it specifies which part of the source document should be processed: by
          default it uses the nested content of the node. You may overwrite this default and assign
          it another value. Some behaviours take other specialized parameters. For example, the <parameter>
          alternate</parameter> behaviour accepts two parameters: <parameter>default</parameter> and <parameter>
          alternate</parameter> . An alternate switches between two alternative states. On the web
          this could take the form of a popup, in print it is usually implemented as a footnote. </para>
        <para> To put this to a test, let's look at the <tag>date</tag> elements appearing within
          the letter. Most of them also specify a normalized date in their <parameter>@when</parameter>
          attribute. Seeing this may be helpful for the reader, for example, to know that the <parameter>
          19th</parameter> mentioned in the postscript refers to <parameter>1957-12-19</parameter> .
          However, we may want to present the normalized date in a more readable way. XPath has a
          function <function>format-date</function> for the purpose and we could use it to show a
          representation of the date nicely formatted in the user's language. </para>
        <para> Add a new element spec for <tag>date</tag> . You'll already see 4 predefined models.
          The first two are for print only, but the third one does indeed use behaviour <function>
          alternate</function> , which is exactly what we want. Change the parameter value for <parameter>
          alternate</parameter> to format the date: </para>
        <figure>
          <title> Format the normalized date in <parameter>@when</parameter>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen6.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="date" mode="change"&gt;
    &lt;model output="print" predicate="text()" behaviour="inline"/&gt;
    &lt;model output="print" predicate="@when and not(text())" behaviour="inline"&gt;
        &lt;param name="content" value="@when"/&gt;
    &lt;/model&gt;
    &lt;model output="web" predicate="@when" behaviour="alternate"&gt;
        &lt;param name="default" value="."/&gt;
        &lt;param name="alternate" value="format-date(@when, '[FNn], [D1o] [MNn], [Y]')"/&gt;
    &lt;/model&gt;
    &lt;model predicate="text()" behaviour="inline"/&gt;
&lt;/elementSpec&gt;</programlisting>
      </section>
      <section xml:id="odd-customization-screencast">
        <title>Screencast</title>
        <para>The screencast below recapitulates some of the modifications we just applied. It uses
          an older version of TEI Publisher, but the basic concepts and controls are still the same:</para>
        <figure xml:id="edit-odd">
          <title>Screencast</title>
          <mediaobject>
            <videoobject>
              <videodata fileref="https://www.youtube.com/embed/avRO-b2BwUI?rel=0" width="853"
                depth="480" />
            </videoobject>
          </mediaobject>
        </figure>
      </section>
      <section xml:id="oddxml">
        <title>Edit the ODD XML by hand</title>
        <para> To switch to the XML source code of the currently edited ODD from within the visual
          editor, click on the button with the angle brackets in the toolbar of the left side panel.
          If you made changes in the form, you need to save first to update the ODD. The ODD XML
          will be opened in a new tab, showing eXist's browser-based editor, <emphasis role="bold">
          eXide</emphasis> . </para>
        <para> While using <emphasis role="bold">eXide</emphasis> is sufficient for small edits, we
          really recommend using specialized XML editor like <emphasis role="bold">oXygen</emphasis>
          for serious work on your TEI files. It will help you with many tasks, starting with the
          syntax and documentation. You can edit ODDs stored in eXist using Oxygen's <emphasis>
          webdav</emphasis> support or the <emphasis>eXist data source</emphasis> function. </para>
        <note>
          <title>Important</title>
          <para> If you edit the ODD XML by hand, there are some caveats you need to be aware of:
            the visual editor will automatically check if there are existing <tag>elementSpec</tag>
            s for a new element in any of the ODDs your ODD inherits from. When editing by hand, you
            need to do this yourself. It's best to always have the base ODDs: <link
              xlink:href="odd/tei_simplePrint.odd" role="source">
              <filename>tei_simplePrint.odd</filename>
            </link> and <link
              xlink:href="odd/teipublisher.odd" role="source">
              <filename>teipublisher.odd</filename>
            </link> open on the side. Both are
            located in the same collection as your odd, i.e. <filename>/db/apps/tei-publisher/odd</filename>
            . </para>
          <para> For example, to modify the element spec for <tag>dateline</tag> , check <filename>
            tei_simplePrint.odd</filename> , where you'll find a definition already. Copy it over to
            your ODD and start modifying it. </para>
          <para> Pay attention to the <option>@mode</option> attribute on <tag>elementSpec</tag> .
            You must set this to <parameter>change</parameter> if you are overwriting an elementSpec
            which already exists in the inherited ODDs. If not, set it to <parameter>add</parameter>
            . </para>
        </note>
        <para> To test any changes, switch back to the tab in which you viewed your document (e.g.
          Graves' letter) and select <guibutton>Admin</guibutton> / <guibutton>Recompile ODD</guibutton>
          from the menu. </para>
      </section>
    </section>

    <section xml:id="pm-syntax">
      <title>Processing Model Syntax</title>
      <para>TEI gives users a lot of freedom: there's always more than one way to encode your
        material! To maintain interoperability and sustainability, you need a way to formally
        describe the schema used as well as document editorial guidelines and transcription
        processes. TEI ODD was designed for the purpose of expressing all this in the TEI language
        itself. But how a document should be rendered was previously still considered to be the
        responsibility of external publishing software and could not be described within the ODD.</para>
      <para> The advent of the TEI Processing Model changed this! The intended processing for all
        elements can now be expressed within the TEI vocabulary as part of the ODD thus fulfilling
        its promise of <emphasis role="bold">One Document Does It All</emphasis> . Markup elements
        are mapped to a small set of abstract transformation functions, called <emphasis role="bold">
        behaviours</emphasis> . Basic styling features can be set directly within the ODD using CSS.
        The processing model is media-agnostic: behaviours and rendition styles are transparently
        translated into different output media types like HTML, XSL-FO, LaTeX, or ePUB. A single ODD
        can handle a multitude of output media types with just a few small adjustments. </para>
      <section xml:id="pm-syntax-model">
        <title>
          <tag>model</tag> element </title>
        <para>
          <tag>model</tag> element is primarily used to document the intended processing for a given
          element. One or more of these elements may appear directly within an <tag>elementSpec</tag>
          element specification to define the processing anticipated for that element. Where
          multiple <tag>model</tag> elements appear, they are understood to document mutually
          exclusive processing scenarios, possibly for different outputs or applicable in different
          contexts. </para>
        <para> A processing model defines on an abstract level how a given element may be
          transformed to produce one or more outputs. The model is expressed in terms of <emphasis
            role="bold">behaviours</emphasis> and their parameters, using high-level formatting
          concepts, such as <parameter>block</parameter> , <parameter>inline</parameter> , <parameter>
          note</parameter> or <parameter>heading</parameter> . A processing model is thus a template
          description, used to generate the code needed by the publishing application to process the
          source document into required output. </para>
        <para> The example below depicts a situation where a single model is defined for the <tag>
          app</tag> element. As no <parameter>@predicate</parameter> or <parameter>@output</parameter>
          are specified, this model applies for all contexts in which <tag>app</tag> may appear and
          all possible outputs. Thus all <tag>app</tag> elements will be transformed into inline
          chunks of text containing only contents of <tag>app</tag> 's <tag>lem</tag> child and
          omitting any possible <tag>rdg</tag> children. </para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="app"&gt;
  &lt;model behaviour="inline"&gt;
    &lt;param name="content" value="lem"/&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <section xml:id="pm-syntax-model-children">
          <title>
            <tag>model</tag> children and attributes: </title>
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  <parameter>@predicate</parameter> : the condition under which this model applies,
            given as an XPath Predicate Expression </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@behaviour</parameter> : names the function which this processing model
            uses in order to produce output; possible values include: alternate, block, figure,
            heading, inline, link, list, note, paragraph </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@output</parameter> : identifier of the intended output for which this
            model applies; applies to all output if no @output is present on a <tag>model</tag>
                </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@useSourceRendition</parameter> : whether to obey any rendition
            attribute which is present in the source document </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@cssClass</parameter> : one or more CSS class names which should be
            added to the resulting output element where applicable </para>
              </listitem>
              <listitem>
                <para>
                  <tag>param</tag> : allows to pass parameters to @behaviour function; parameters
            available depend on the behaviour in question; when parameters are not explicitly
            passed, default values for those are assumed; all behaviour functions use current
            element as default content </para>
              </listitem>
              <listitem>
                <para>
                  <tag>outputRendition</tag> : supplies information about the desired output
            rendition in CSS; its attribute @scope provides a way of defining ‘pseudo-elements’ eg:
            first-line, first-letter, before, after </para>
              </listitem>
            </itemizedlist>
          </para>
          <para> Model explicitly specifying content parameter: for <tag>app</tag> entries only
            content of its <tag>lem</tag> child is to be displayed (as an inline chunk of text): </para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="app"&gt;
  &lt;model behaviour="inline"&gt;
    &lt;param name="content" value="lem"/&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para> Model specifying output rendition: contents of <tag>ex</tag> elements are to be
            displayed in italic and wrapped in parentheses: </para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="ex"&gt;
  &lt;model behaviour="inline"&gt;
    &lt;outputRendition&gt;font-style: italic;&lt;/outputRendition&gt;
    &lt;outputRendition scope="before"&gt;
      content:"(";&lt;/outputRendition&gt;
    &lt;outputRendition scope="after"&gt;content:")";&lt;/outputRendition&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para> Sometimes different processing models are required for the same element in
            different contexts. For example, we may wish to process the <tag>quote</tag> element as
            an inline italic element when it appears inside a <tag>p</tag> element, but as an
            indented block when it appears elsewhere. To achieve this, we need to change the
            specification for the <tag>quote</tag> element to include two <tag>model</tag> elements
            as follows: </para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="quote"&gt;
  &lt;model predicate="ancestor::p" behaviour="inline"&gt;
    &lt;outputRendition&gt;font-style: italic;&lt;/outputRendition&gt;
  &lt;/model&gt;
  &lt;model behaviour="block"&gt;
    &lt;outputRendition&gt;
      left-margin: 2em;
    &lt;/outputRendition&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para> The first processing model will be used only for <tag>quote</tag> elements which
            match the XPath expression given as value for the <parameter>@predicate</parameter>
            attribute. Other element occurrences will use the second processing model. Set of
            multiple <tag>model</tag> statements is regarded as an alternation and only the first
            model with <parameter>@predicate</parameter> matching current context is applied. </para>
        </section>
        <section xml:id="model-styling">
          <title>
            <tag>model</tag> output styling </title>
          <para>The intended rendering for a particular behaviour of a processing model may be
            specified in one or all of the three following ways.</para>

          <itemizedlist>
            <listitem>
              <para> the <parameter>@cssClass</parameter> attribute may be used to specify the name
                of a CSS style in an associated CSS stylesheet (read more on <link
                  linkend="external-css">specifying CSS styles in the ODD</link> ) which is to be
                applied to each occurrence of a specified element found (in a given context, for a
                specified output), </para>
            </listitem>
            <listitem>
              <para> the attribute <parameter>@useSourceRendition</parameter> may be used to
                indicate that the rendition specified in the source document should be applied, </para>
            </listitem>
            <listitem>
              <para> the styling to be applied may be specified explicitly as content of a child <tag>
                outputRendition</tag> element. </para>
            </listitem>
          </itemizedlist>
          <para> When more than one of these options is used, they are understood to be combined in
            accordance with the rules for multiple declaration of the styling language used. </para>
          <para> It is strongly recommended that use <tag>outputRendition</tag> should be limited to
            strictly editorial decisions, such as 'conjectures are to be displayed in square
            brackets' and not as means to record all typesetting and layout specific design choices.
            The latter are discussion in the <link linkend="css-styling">Custom CSS styling</link>
            chapter. </para>
          <para> The processing model library translates the CSS styles into the target media
            format. Restrictions apply due to differences between the output formats. Not all CSS
            properties are supported for every format. Please refer to the section on <link
              linkend="output-media">Output media settings</link> for further information. </para>


        </section>
      </section>
      <section xml:id="pm-syntax-modelSequence">
        <title>
          <tag>modelSequence</tag> and <tag>modelGrp</tag>
        </title>
        <para> Summary of elements that can be used to document one or more processing models for a
          given element: <itemizedlist>
            <listitem>
              <para>
                <tag>model</tag> describes the processing intended for a specific context </para>
            </listitem>
            <listitem>
              <para>
                <tag>modelSequence</tag> (sequence of processing models) a group of model elements
          documenting intended processing models for this element, to be acted upon in sequence </para>
            </listitem>
            <listitem>
              <para>
                <tag>modelGrp</tag> (processing model group) a group of model elements documenting
          intended processing models for this element </para>
            </listitem>
          </itemizedlist>
        </para>
        <para> The <tag>modelGrp</tag> element may be used to group alternative <tag>model</tag>
          elements intended for a single kind of output. The <tag>modelSequence</tag> element is
          provided for the case where a sequence of models is to be processed, functioning as a
          single unit. Common use case would be to use modelSequence to generate table of contents
          along with the reading text as shown in the example below: </para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="body"&gt;
  &lt;modelSequence&gt;
    &lt;model behaviour="index"&gt;
      &lt;param name="type" value="'toc'"/&gt;
    &lt;/model&gt;
    &lt;model behaviour="block"/&gt;
  &lt;/modelSequence&gt;
&lt;/elementSpec&gt;</programlisting>
      </section>

      <section xml:id="behaviours">
        <title>Behaviours</title>
        <para> The <link xlink:show="new"
            xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-model.html">TEI
          guidelines</link> document a number of default behaviours. TEI Publisher allows users to
          add their own behaviours, either within the ODD itself or by writing <link
            linkend="extension-modules">XQuery code</link> . The following section lists the default
          behaviours. </para>
        <section xml:id="behaviours-available">
          <title>Available Behaviours</title>
          <para> Behaviour functions accept a range of parameters, depending on the function in
            question. Where these parameters are left unspecified in the <tag>model</tag> , default
            values are used. All functions take at least one parameter: <parameter>content</parameter>
            . It will be added by default unless specified and contains the nested content of the
            currently processed node. You may change this by explicitely setting a <parameter>
            content</parameter> parameter inside the model. </para>
          <para> In the parameter lists below we skip the <parameter>content</parameter> parameter
            as it is available for every behaviour. Optional parameters are marked as <emphasis>
            optional</emphasis> in parenthesis, followed by the output mode they apply for, if
            relevant. </para>
          <variablelist>
            <varlistentry>
              <term>alternate</term>
              <listitem>
                <para>Display alternating elements for displaying the preferred version and an
                  alternative, both at once or by some method of toggling between the two. The
                  concrete implementation depends on the output format.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>default</td>
                      <td>the content to display by default</td>
                    </tr>
                    <tr>
                      <td>alternate</td>
                      <td>alternate content</td>
                    </tr>
                    <tr>
                      <td>persistent</td>
                      <td>(optional, web) show a persistent popup on click instead of a tooltip on
                        hover if parameter evaluates to an effective boolean value of true</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>anchor</term>
              <listitem>
                <para>Create an anchor to which you can link, identified by the given id.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>id</td>
                      <td>the id</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>block</term>
              <listitem>
                <para>Create a block structure, usually a div in HTML or fo:block in fo.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>body</term>
              <listitem>
                <para>Create the body of a document. In HTML this will result in a &lt;body&gt; tag.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>break</term>
              <listitem>
                <para>Create a line, column, or page break according to type.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>type</td>
                      <td>e.g. "page", "column", "line"</td>
                    </tr>
                    <tr>
                      <td>label</td>
                      <td>e.g. "p. 13v"</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>cell</term>
              <listitem>
                <para>Create a table cell. If the @cols or @rows attribute is specified, the cell
                  may span several columns/rows.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>cit</term>
              <listitem>
                <para>Show a citation, with an indication of the source.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>source</td>
                      <td>the citation source</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>document</term>
              <listitem>
                <para>Start a new output document.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>figure</term>
              <listitem>
                <para>Make a figure with provided title argument as caption</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>title</td>
                      <td>a caption</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>graphic</term>
              <listitem>
                <para>Display the graphic retrieved from the given url.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>url</td>
                      <td>the url to load the graphic from</td>
                    </tr>
                    <tr>
                      <td>width</td>
                      <td>the width of the graphic, e.g. "300px", "50%" ...</td>
                    </tr>
                    <tr>
                      <td>height</td>
                      <td>the height of the graphic, e.g. "300px", "50%" ...</td>
                    </tr>
                    <tr>
                      <td>scale</td>
                      <td>a scaling factor to apply. If specified, width and height will be output
                        as percentage based on the scaling factor, which should be a number between
                        0 and 1.</td>
                    </tr>
                    <tr>
                      <td>title</td>
                      <td>a title for the graphics element. Usually not shown directly.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>heading</term>
              <listitem>
                <para>Creates a heading.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>level</td>
                      <td>the structural level of this heading. In HTML mode, this translates to
                        &lt;h1&gt;, &lt;h2&gt; etc.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>inline</term>
              <listitem>
                <para>Outputs an inline element.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>link</term>
              <listitem>
                <para>Create a hyperlink.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>uri</td>
                      <td>the link url</td>
                    </tr>
                    <tr>
                      <td>target</td>
                      <td>identifier of the tab to open the link in (only web output)</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>list</term>
              <listitem>
                <para> Creates an ordered or unordered list, depending on the type attribute (e.g. <parameter>
                  type="ordered"</parameter> ). If a label is present before each item, a
                  description list is output instead, using the label as definition term. </para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>type</td>
                      <td> The type of list: use "ordered" for an enumerated list, or "custom" to
                        specify item labels in combination with the <option>n</option> parameter on
                        each <command>listItem</command> . The default is "unordered" for a list of
                        bullet points. </td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>listItem</term>
              <listitem>
                <para>Outputs an item in a list.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>n</td>
                      <td>a label to use for the item</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>metadata</term>
              <listitem>
                <para>Outputs a metadata section, e.g. a &lt;head&gt; in HTML.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>note</term>
              <listitem>
                <para> create a note, often out of line, depending on the value of <code>place</code>
                  ; could be "margin", "footnote", "endnote", "inline" </para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>place</td>
                      <td>defines the placement of the note, e.g. "margin", "footnote" ...</td>
                    </tr>
                    <tr>
                      <td>label</td>
                      <td>the label to use for the footnote reference, usually a number.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>omit</term>
              <listitem>
                <para> Do nothing, skip this element, do not process children </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>paragraph</term>
              <listitem>
                <para> Create a paragraph. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>row</term>
              <listitem>
                <para> Create a table row. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>section</term>
              <listitem>
                <para>Create a new section in the output document. In HTML mode, this translates to
                  a &lt;section&gt; element being output.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>table</term>
              <listitem>
                <para>Create a table.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>text</term>
              <listitem>
                <para>Output literal text.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>title</term>
              <listitem>
                <para>Output the document title. In HTML mode, this creates a &lt;title&gt; element.
                  In LaTeX, it adds the title to the document metadata.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>webcomponent (TEI Publisher extension)</term>
              <listitem>
                <para> Outputs a custom HTML element (usually referencing a webcomponent) using the
                  value of parameter <parameter>name</parameter> as tag name. All other parameters
                  are copied into corresponding attributes (properties of the webcomponent). </para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>name</td>
                      <td>the tag name to use for the custom element. Must be a string value.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

    </section>

    <section xml:id="external-css">
      <title>Including General CSS Styles</title>
      <para> TEI Publisher is based on webcomponents, therefore styling of one document will not
        interfere with the styling of another document on the same page. All styles are strictly
        encapsulated within the component and do not "pollute" the global browser space. This also
        has a downside though: CSS rules defined outside the <tag>pb-view</tag> have no influence on
        the text styling inside the component (with some exceptions, mainly for properties which are
        inherited down the HTML tree, e.g. <parameter>font-family</parameter> ). </para>
      <para> However, putting <emphasis>all</emphasis> styling information into <tag>outputRendition</tag>
        tags within the ODD is also not a good idea - it adds a lot of redundancy and mixes
        editorial responsibilities with web design concerns. </para>
      <para> The recommended solution would therefore be to use CSS classes for repeating styling
        aspects. TEI Publisher supports linking to an external CSS stylesheet from the <code>
        encodingDesc/tagsDecl/rendition</code> section of the ODD. Just specify a relative link in
        the <parameter>@source</parameter> attribute: </para>
      <programlisting language="xml" xml:space="preserve">
                  &lt;rendition source="docbook.css"/&gt;
          </programlisting>
      <para>The file should be stored in the same collection as the source ODD it is referenced
        from. The linked file should be a standard CSS stylesheet.</para>
      <para>Note that unfortunately, editing renditions is not yet supported by the visual ODD
        editor, so you will have to fall back to add the corresponding elements to the ODD by hand.</para>
      <para> Alternatively, one may also use the same TEI element <tag>rendition</tag> with the <parameter>
        @selector</parameter> attribute to embed CSS rules directly in the ODD. </para>

      <programlisting language="xml" xml:space="preserve">&lt;rendition selector="h3"&gt;
  font-family: serif;
  font-weight: 400;
&lt;/rendition&gt;</programlisting>
      <para>Choose one of the two approaches, but do not mix them. In both cases make sure to
        recompile the ODD after changes as the CSS is merged into the generated code!</para>

      <para> New addition in Publisher 6.0 allows to pass the external CSS file in <code>load-css</code>
        attribute of <code>pb-view</code> . Recompiling ODD in this case is not necessary, otherwise
        it is functionally equivalent to using ODD <code>rendition</code> . </para>
    </section>

    <section xml:id="output-media">
      <title>Output Media Settings</title>
      <para> The library supports various output media formats and translates styles into the
        corresponding format. Currently the following output modes are supported and can be used in
        the <parameter>@output</parameter> attribute: </para>
      <variablelist>
        <varlistentry>
          <term>web</term>
          <listitem>
            <para>Produces HTML output</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>fo</term>
          <listitem>
            <para>Generates a PDF via XSL:FO</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>latex</term>
          <listitem>
            <para>Creates a PDF via LaTeX</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>print</term>
          <listitem>
            <para>Extends web output with a focus on Print and Paged Media</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>epub</term>
          <listitem>
            <para>A specialization of the web output mode targetted at epub documents</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>The quality of the generated output may vary a lot for the fo and latex modes, depending
        on the type of input document. The following section provides more details on the
        configuration of the FO output option:</para>
      <section xml:id="output-media-fo">
        <title>FO Output</title>
        <para>When generating XSL:FO output, the implementation tries to translate the CSS rules
          specified for renditions into the corresponding XSL:FO formatting properties. Not all CSS
          properties are recognized or can be mapped to FO properties. Unknown properties defined in
          a rendition will be ignored.</para>
        <para>The default rendering for headings, paragraphs and the like is defined by a separate
          CSS file. The implementation merges those defaults with the custom renditions given in the
          ODD.</para>
        <para> The library searches for default CSS styles in a file named <filename>
          &lt;odd-name&gt;.fo.css</filename> inside the specified output collection (in which the
          generated XQuery files are stored). The style definitions are copied literally into
          attributes on the output XSL:FO elements, so any property which is a valid attribute for
          the corresponding element may be used. For example, <filename>teipublisher.fo.css</filename>
          contains: </para>
        <programlisting language="css" xml:space="preserve">
.tei-text { font-family: "Junicode"; hyphenate: true; }
.tei-floatingText { padding: 6pt; }
.tei-p { text-align: justify; }
        </programlisting>
        <para>Every XSL:FO document needs a master layout and a page sequence definition. Because
          those tend to be rather verbose as they include things like page margins etc., they are
          read from two XML files:</para>
        <variablelist>
          <varlistentry>
            <term>master.fo.xml</term>
            <listitem>
              <para>Contains the layout master set</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>page-sequence.fo.xml</term>
            <listitem>
              <para>Defines the main page sequence</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>The mechanisms for configuring FO output are still very much under development and we
          welcome suggestions by users.</para>
      </section>
      <section xml:id="output-media-latex">
        <title>LaTeX Output</title>
        <para>The latex output mode produces good results for longer texts which fit well into the
          pre-defined LaTeX environments. The number of supported CSS properties is limited though:</para>
        <itemizedlist>
          <listitem>
            <para>font-weight</para>
          </listitem>
          <listitem>
            <para>font-style</para>
          </listitem>
          <listitem>
            <para>font-variant</para>
          </listitem>
          <listitem>
            <para>font-size</para>
          </listitem>
          <listitem>
            <para>color</para>
          </listitem>
          <listitem>
            <para>text-decoration</para>
          </listitem>
          <listitem>
            <para>text-align</para>
          </listitem>
          <listitem>
            <para>text-indent</para>
          </listitem>
        </itemizedlist>
        <para> To create arbitary complex LaTeX output, you may want to use the <link
            linkend="pb-template">
            <tag>pb-template</tag> extension </link> to the ODD syntax. It is heavily used to e.g.
          generate the LaTeX version of this documentation. See also <link
            xlink:href="odd/serafin.odd" role="source">serafin.odd</link> or <link
            xlink:href="odd/vangogh.odd" role="source">vangogh.odd</link> for examples. </para>
        <para> TEI Publisher creates a default LaTeX prolog based on standard packages and settings.
          You may overwrite the defaults by providing your own template within the ODD element spec
          for the TEI root element. See the example ODDs mentioned above. Note that TEI Publisher
          will generate some LaTeX macros for styles defined in <tag>outputRendition</tag> which
          should be imported into the prolog. The styles are added to the default configuration map
          and can be accessed via <command>$config('latex-styles')</command> . Refer to the example
          ODDs and just copy/paste the corresponding lines. </para>
        <para> This output mode requires a local installation of LaTeX on the machine running TEI
          Publisher. The examples have been tested on a default installation of MacTeX 2018. If you
          are not running MacTeX, you likely need to adjust the path to the LaTeX binary in the
          XQuery configuration module <filename>modules/config.xqm</filename> . Search for the
          variable <parameter>$config:tex-command</parameter> and adjust it to point to a binary of <command>
          xelatex</command> , <command>pdflatex</command> or <command>lualatex</command> . </para>
      </section>
      <section xml:id="output-media-epub">
        <title>ePub Output</title>
        <para> The <parameter>epub</parameter> output mode extends the HTML mode. You may define
          general styling in an extra CSS file, located in <filename>resources/css/epub.css</filename>
          . This external stylesheet is included into all generated epub files and may be used to
          configure general settings like page breaks, hyphenation, font sizes etc. </para>
      </section>
      <section xml:id="output-print-css">
        <title>Print CSS</title>
        <para>This output mode targets printed HTML. Browser support for the corresponding CSS
          specifications is not very good, but there are various tools to improve this. If you
          select the print CSS download option for any of the documents in TEI Publisher, which
          support it, you will be directed to a preview page. This page uses a library called <link
            xlink:href="https://pagedjs.org/">paged.js</link> to "teach" the browser how to handle
          certain layout aspects. Thanks to this, using the <command>print page</command> dialog of
          your browser will result in a much nicer page layout than if you just tried to print TEI
          Publisher's document view.</para>
        <para>The preview page uses TEI Publisher's <code>pb-print-preview</code> web component.
          This component will retrieve the full HTML of the document, enhanced with additional CSS
          stylesheets for print, and passes it to paged.js for the page formatting. For testing
          purposes you can also click on the bottom-most button with the <guibutton>eye</guibutton>
          icon to see the raw HTML (without paged.js applied).</para>
        <para>To generate the HTML of the document, the component calls Publisher's API endpoint:</para>

        <synopsis>/api/document/doc%2Fdocumentation.xml/print</synopsis>
        <para>The following (optional) parameters are supported:</para>
        <variablelist>
          <varlistentry>
            <term>base</term>
            <listitem>
              <para>specifies the base URI for resolving relative links, e.g. to locate images</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>style</term>
            <listitem>
              <para>one or more additional CSS stylesheet URLs to be imported into the page.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>script</term>
            <listitem>
              <para>one or more Javascript files to be loaded via <tag>script</tag>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>wc</term>
            <listitem>
              <para>if set, include TEI Publisher's web component libraries. You may need this if
                you are using components like <tag>pb-code-highlight</tag> (as in the documentation)</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>For sure, being an open source project, paged.js does not support every fancy layout
          you may wish for. For example, support for formatting footnotes will be limited. There are
          other, mainly commercial tools, which you may use to generate PDF out of your HTML. Those
          include e.g. <link xlink:href="https://www.princexml.com/">Prince XML</link>, <link
            xlink:href="https://www.pdfreactor.com/">PDF Reactor</link> or <link
            xlink:href="https://antennahouse.com/">Antennahouse</link>. Each of those may have
          different strengths and weaknesses. Please try yourself.</para>

        <para>For command line tools, you can use the API endpoint described above to retrieve the
          full HTML of the page and feed this to PrinceXML or whatever you want to use. To simplify
          this, the preview page includes a button at the bottom: clicking it will copy the API
          endpoint URL (excluding the page.js components, which would interfere with external
          tools). The screenshot below shows princeXML's dialog into which you can paste the URL
          provided by the preview page:</para>

        <figure>
          <title> Processing Print HTML with PrinceXML </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="prince-screenshot.png" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>


    <section xml:id="pm-extensions">
      <title>Extensions to the Processing Model Specification</title>
      <section xml:id="pm-extensions-xquery">
        <title>XQuery Instead of XPath</title>
        <para>The implementation directly translates processing model instructions into an XQuery
          3.1 module by generating executable XQuery code. This is straightforward as the resulting
          XQuery will closely resemble the specification in the ODD, thus being easy to debug. It
          also leads to very efficient code, which is as fast or even faster as a hand-written,
          optimized transformation.</para>
        <para> As a welcome side effect, any valid XQuery expression might be used wherever the spec
          expects an XPath expression, e.g. in predicates or parameters. For example, one can define
          variables inside a parameter using a standard XQuery <code language="xquery">let $x := ...
          return ...</code> syntax. </para>
      </section>
      <section xml:id="pm-extensions-default">
        <title>Default Processing Model Rules</title>
        <para> It is possible to define a default <tag>elementSpec</tag> to be applied to all
          elements which are not already matched by another elementSpec. For example, if no <tag>
          elementSpec</tag> is present for an element, its text content is output. To change this
          behaviour and omit content elements without specification, you may want to define a
          default <tag>elementSpec</tag> as shown below: </para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="*"&gt; &lt;model behaviour="omit"/&gt; &lt;/elementSpec&gt;</programlisting>
        <para>You can also define models to be applied to all text nodes, e.g. if you need to
          normalize certain nodes:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="text()"&gt;
  &lt;model behaviour="text"/&gt;
&lt;/elementSpec&gt;</programlisting>
        <para>Note that outputting text nodes is a performance critical operation, so use with care.
          Too complex processing may dramatically slow down rendering.</para>
      </section>
      <section xml:id="external-parameters">
        <title>External Parameters</title>
        <para> The script calling the processing model may pass external parameters into the ODD.
          They will be available in the variable <parameter>$parameters</parameter> , which is an
          XQuery map. Access parameters using <code>?</code> , the XQuery lookup operator. </para>
        <para>For example, one can use this feature to control how specific parts of the document
          are output, without having to define a separate output mode, which would result in much
          more code. Below we display a shortened header for the document, containing simply its
          title, but only if the parameter "header" is set to "short":</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="fileDesc"&gt;
    &lt;model predicate="$parameters?header='short' behaviour="block" cssClass="header-short"&gt;
      &lt;param name="content" value="titleStmt"/&gt;
    &lt;/model&gt;
  ...
&lt;/elementSpec&gt;</programlisting>
        <para> The <tag>pb-view</tag> webcomponent also lets you define arbitrary parameters to be
          passed to the ODD via <tag>pb-param</tag> . For example, the breadcrumbs shown above this
          documentation page are realized by setting a parameter <parameter>mode</parameter> and can
          be queried in model predicates with <parameter>$parameters?mode='breadcrumbs'</parameter>
          . </para>
        <programlisting language="xml" xml:space="preserve">&lt;section class="breadcrumbs"&gt;
    &lt;pb-view id="title-view1" src="document1" subscribe="transcription"&gt;
        &lt;pb-param name="mode" value="breadcrumbs"/&gt;
    &lt;/pb-view&gt;
&lt;/section&gt;</programlisting>
        <para>If the parameter is set, the processing model rules in the ODD will output the
          headings of all ancestor sections of the current division only, ignoring everything else.
          This approach helps to reuse the same ODD for viewing specific aspects of the document.</para>
        <para> A dedicated user interface webcomponent <link xlink:show="new"
            xlink:href="https://cdn.tei-publisher.com/api.html#pb-toggle-feature.0">
            <tag>pb-toggle-feature</tag>
          </link> exists for toggling between two values of
          a parameter. Example below would produce a checkbox which when on results in the value of <parameter>
          $parameters?mode</parameter> set to <parameter>diplomatic</parameter> , otherwise to <parameter>
          norm</parameter> . </para>
        <programlisting language="xml" xml:space="preserve">&lt;pb-toggle-feature name="mode" on="diplomatic" off="norm"&gt;Diplomatic View&lt;/pb-toggle-feature&gt;</programlisting>
      </section>
      <section xml:id="pm-extensions-templates">
        <title>Code Templates and Custom Behaviours</title>
        <para>The two dozen behaviours defined by the TEI processing model are enough to cover most
          standard HTML output tasks like a listItem or heading, but more complex HTML markup or
          even other output formats like LaTeX require more customization and control over the
          generated output. The TEI Publisher library thus extends the processing model syntax with
          two custom elements for defining code templates.</para>
        <para>While TEI Publisher does provide ways to write your own behaviours in XQuery and thus
          extend the ones defined in the guidelines, this should only be used as last resort: custom
          XQuery behaviours limit the portability of the ODD and are bad for maintenance.</para>
        <para> Avoiding custom behaviours works quite well for HTML output and we have realized
          complex projects with just two or three extension behaviours. Things start to become more
          difficult if you try to output LaTeX though: there are hundreds of packages to use, and
          users typically define their own macros or environments for all recurring typesetting
          tasks. For example, to print a TEI <tag>persName</tag> , experienced LaTeX users would
          normally create a corresponding <code>\persName</code> macro and handle the formatting
          details there. Unfortunately, out of the box the TEI processing model does not facilitate
          this level of customization. </para>
        <section xml:id="pb-template">
          <title> Introducing <tag>pb:template</tag>
          </title>
          <para> TEI Publisher thus supports an extension to the ODD syntax in its own namespace ( <parameter>
            http://teipublisher.com/1.0</parameter> ). </para>
          <para> Within the ODD, a <tag>model</tag> may define a <tag>pb:template</tag> element
            containing a code template. The template is expanded first and the result is passed into
            the behaviour specified for the model, replacing the default <parameter>content</parameter>
            parameter accepted by all behaviours. The very simple case of outputting a <tag>persName</tag>
            in LaTeX could thus be written as: </para>

          <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="persName" mode="add"&gt;
    &lt;model behaviour="inline" output="latex"&gt;
        &lt;pb:template&gt;\persName{[[content]]}&lt;/pb:template&gt;
    &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para> The template can reference other parameters defined within the <tag>model</tag> by
            enclosing the parameter name in double brackets. In the example above we're referencing
            the default parameter <parameter>content</parameter> , which contains the nested content
            of the <tag>persName</tag> tag. The parameter will be processed before it is passed into
            the template, so if <tag>persName</tag> contains nested TEI markup, the corresponding
            processing model rules will be applied first. </para>
          <para> The result of expanding the template then becomes the new <parameter>content</parameter>
            parameter to be passed to the behaviour ( <code>inline</code> in the example above),
            which is processed in the normal way as defined in the TEI guidelines. </para>
          <para> You may also specify additional parameters to be included in the template. For
            example, the TEI document may contain a glossary of terms which are referenced in the
            text using <code>&lt;term ref="#termid"&gt;text&lt;/term&gt;</code> . In LaTeX this
            would translate to <code>\glslink{ref}{text}</code> , which can be easily produced by
            the following <tag>model</tag> : </para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="term" mode="add"&gt;
    &lt;model behaviour="inline" output="latex"&gt;
        &lt;param name="ref" value="substring-after(@ref, '#')"/&gt;
        &lt;pb:template&gt;\glslink{[[ref]]}{[[content]]}&lt;/pb:template&gt;
    &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para> We define an additional parameter <parameter>ref</parameter> , which contains the
            id string from the <parameter>@ref</parameter> attribute, stripping out the leading '#'. </para>
          <para>The templating mechanism is not limited to LaTeX, but may also be used to generate
            HTML or FO, for example, if you have to generate a complex HTML fragment to represent a
            single TEI element. This is hard and sometimes impossible to achieve without templates</para>
          <para>This following sample uses the <parameter>pb-popover</parameter> webcomponent to
            display the tei:persName from a person register for a given tei:persName/@key of your
            TEI document. </para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="persName" mode="add"&gt;
        &lt;model behaviour="inline" cssClass="popover"&gt;
            &lt;param name="content" value="."/&gt;
            &lt;param name="key" value="@key"/&gt;
            &lt;param name="person-from-register" value="doc('/path/to/person.xml')//person[@id = @key]/persName[@type='full']/text()"&gt;
            &lt;pb:template xmlns="" xml:space="preserve"&gt;
                &lt;pb-popover data-ref="[[key]]"&gt;
                    &lt;span slot="default"&gt;[[content]]&lt;/span&gt;
                    &lt;span slot="alternate"&gt;[[person-from-register]]&lt;/span&gt;
                &lt;/pb-popover&gt;
            &lt;/pb:template&gt;
        &lt;/model&gt;
        </programlisting>
        </section>
        <section xml:id="pb-behaviour">
          <title>Defining New Behaviours in the ODD</title>
          <para>By combining code templates with parameters we can come up with a very simple
            mechanism to define new behaviours right inside the ODD!</para>
          <para> Take the TEI Publisher documentation as an example: it is written in docbook 5 and
            transformed via ODD. The documentation includes some videos which are hosted on youtube.
            In docbook those are represented by <tag>videodata</tag> elements inside a <tag>
            videoobject</tag> : </para>
          <programlisting xml:space="preserve">&lt;figure xml:id="edit-odd"&gt;
    &lt;title&gt;Screencast&lt;/title&gt;
    &lt;mediaobject&gt;
      &lt;videoobject&gt;
        &lt;videodata fileref="https://www.youtube.com/embed/avRO-b2BwUI?rel=0" width="853" depth="480"/&gt;
      &lt;/videoobject&gt;
    &lt;/mediaobject&gt;
&lt;/figure&gt;</programlisting>
          <para> In the HTML output we would need to transform this into an <tag>iframe</tag> , so
            the reader can view the video embedded in the page. We can achieve this with a <tag>
            pb:template</tag> as sketched in the previous section, but it would be nice to turn this
            into a general-purpose behaviour, which we can re-use in other situations requiring an
            iframe. The TEI Publisher library allows us to define a behaviour right inside the ODD
            as follows: </para>

          <programlisting xml:space="preserve">&lt;pb:behaviour ident="iframe" output="web"&gt;
    &lt;pb:param name="src"/&gt;
    &lt;pb:param name="width"/&gt;
    &lt;pb:param name="height"/&gt;
    &lt;pb:template xmlns=""&gt;
        &lt;iframe src="[[src]]" width="[[width]]" height="[[height]]" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;
    &lt;/pb:template&gt;
&lt;/pb:behaviour&gt;</programlisting>

          <note>
            <title>Note</title>
            <para> Note how we have to reset the namespace on the <tag>pb:template</tag> ? This is
              required because the default namespace in an ODD document is the TEI namespace. You
              thus need to reset it whenever you want to output elements in another or no namespace
              inside a template. Without this, the iframe would end up in the TEI namespace.
              Webbrowsers will usually ignore it, but it will be wrong nevertheless. </para>
          </note>
          <para> All behaviours should be included in the TEI header or - to be exact: the <tag>
            tagsDecl</tag> inside the <tag>encodingDesc</tag> . You may have multiple behaviour
            declarations with the same <parameter>@ident</parameter> , given that they apply to
            different <parameter>@output</parameter> modes. Parameters specified via <tag>pb:param</tag>
            without <parameter>@value</parameter> attribute are expected to be passed to the
            behaviour from the calling model. A parameter may be empty though. If you define an
            XPath expression as <parameter>@value</parameter> attribute, the result of the XPath
            evaluation will be used as value for the parameter. </para>
          <para> The new behaviour will be named <function>iframe</function> and takes three
            parameters: <parameter>src</parameter> , <parameter>width</parameter> and <parameter>
            height</parameter> . It can now be called from a <tag>model</tag> as follows: </para>
          <programlisting xml:space="preserve">&lt;model behaviour="iframe"&gt;
    &lt;param name="width" value="@width"/&gt;
    &lt;param name="height" value="@depth"/&gt;
    &lt;param name="src" value="@fileref"/&gt;
&lt;/model&gt;</programlisting>
          <para> For further code examples, please have a look at <link xlink:href="odd/docbook.odd"
              role="source">docbook.odd</link> , which is used for viewing the documentation. </para>
          <note>
            <title>Note</title>
            <para> At the time of writing, the graphical ODD editor in TEI Publisher does not yet
              support defining your own behaviours via <tag>pb-behaviour</tag> . You thus have to
              make those changes in the source XML using eXide, oXygen or another XML editor. You
              can, however, use the graphical editor to continue editing the ODD afterwards. It is
              smart enough to not overwrite your hand-written code upon save. </para>
          </note>
        </section>
      </section>

      <section xml:id="extension-modules">
        <title>Extension Modules</title>
        <para> Where possible, developers should stick to the standard behaviours defined by the TEI
          guidelines, or use the <tag>pb-behaviour</tag> and <tag>pb-template</tag>
        <link
            linkend="pb-behaviour">extensions</link> of the ODD syntax. However, there might be
          situations in which it is necessary to generate a specific type of complex output, which
          requires the full power of XQuery. To facilitate this, the implementation allows
          additional extension modules to be configured: </para>
        <section xml:id="extension-configuration">
          <title>Configuration</title>
          <para> Configuration is done via an XML file which must reside in the same collection as
            the source ODD files. It contains a series of <tag>output</tag> elements, representing
            particular output modes (e.g. web or print) via <parameter>@mode</parameter> attribute. <tag>
            output</tag> element without a mode groups modules available for all output modes. </para>
          <para> Each <tag>output</tag> element lists modules to be loaded for specified output
            mode. Each definition may optionally be limited to a specific ODD, name of which is
            specified in the <parameter>@odd</parameter> attribute. </para>
          <programlisting language="xml" xml:space="preserve">&lt;modules&gt;
    &lt;!-- functions or behaviours common to all output modes --&gt;
    &lt;output&gt;
      &lt;module uri="http://www.tei-c.org/tei-simple/xquery/common-functions" prefix="tc" at="xmldb:exist:///db/apps/my-app/modules/common.xql"/&gt;
    &lt;/output&gt;
    &lt;!-- General fo extension functions --&gt;
    &lt;output mode="print"&gt;
      &lt;module uri="http://www.tei-c.org/tei-simple/xquery/ext-fo" prefix="ext-fo" at="xmldb:exist:///db/apps/tei-publisher/modules/ext-fo.xql"/&gt;
    &lt;/output&gt;
    &lt;!-- Special web configuration for the documentation (to handle &lt;code&gt;) --&gt;
    &lt;output mode="web" odd="documentation"&gt;
      &lt;module uri="http://www.tei-c.org/tei-simple/xquery/ext-html" prefix="ext-html" at="xmldb:exist:///db/apps/tei-publisher/modules/ext-html.xql"/&gt;
    &lt;/output&gt;
&lt;/modules&gt;</programlisting>
          <para> Whenever the library tries to locate a processing model function for a given
            behaviour, it will <emphasis role="bold">first</emphasis> check any extension module it
            knows to see if it contains a matching function. One can thus <emphasis role="bold">
            overwrite</emphasis> the default functions as well as define new ones. </para>
          <para> An extension module may also contain general purpose XQuery functions you want to
            call from within an ODD parameter, e.g. for formatting a date, outputting a number etc.
            To make those functions available to all output modes, just skip the <parameter>@mode</parameter>
            attribute. </para>
        </section>
        <section xml:id="extension-modules-behaviours">
          <title>Implementing Custom Behaviours</title>
          <para>To be recognized by the library, an extension function must accept at least 4
            default arguments, plus any number of custom parameters. The required parameters are:</para>
          <variablelist>
            <varlistentry>
              <term>$config</term>
              <listitem>
                <para> a map containing configuration information as well as function references to
                  be called. The most important ones are <function>$config?apply($config, $node)</function>
                  and <function>$config?apply-children($config, $node, $content)</function> . Both
                  are function items and when called, continue processing with either a single <parameter>
                  $node</parameter> or a sequence of nodes in <parameter>$content</parameter> . </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>$node</term>
              <listitem>
                <para>the TEI element being processed at the moment</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>$class</term>
              <listitem>
                <para> a list of HTML class names to be used. This includes automatically generated
                  class names as well as those passed via <parameter>@cssClass</parameter> on a
                  model item. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>$content</term>
              <listitem>
                <para> because <parameter>content</parameter> is defined for every model rule, it is
                  always passed to a behaviour function (though it might be empty) </para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para> For all additional parameters, the processing model implementation tries to fill
            each custom parameter with a corresponding value by looking through the <tag>param</tag>
            children of the <tag>model</tag> in the ODD to find one with a name matching the
            variable name. If no matching parameter can be found, the function argument will be set
            to the empty sequence. You should not enforce a type or cardinality for any of the
            custom parameters as this may lead to unexpected errors. The parameters may be empty or
            contain more than one item. </para>
          <para> For example, a custom behaviour called <code>code</code> for syntax highlighting in
            an extension module named <filename>ext-html.xql</filename> might look as follows: </para>
          <programlisting language="xquery" xml:space="preserve">xquery version "3.1";
(:~ : Non-standard extension functions, mainly used for the documentation. :)
module namespace pmf="http://www.tei-c.org/tei-simple/xquery/ext-html";
declare namespace tei="http://www.tei-c.org/ns/1.0";

declare function pmf:code($config as map(*), $node as element(), $class as xs:string+, $content as node()*, $lang as item()?) {
    &lt;pre class="code {$class}" data-language="{if ($lang) then $lang else 'xquery'}"&gt;
    {replace(string-join($content/node()), "^\s+?(.*)\s+$", "$1")}
    &lt;/pre&gt;
};</programlisting>
          <para> It defines one function, <function>pmf:code</function> , which can be called from
            the ODD as follows, provided that the <filename>ext-html.xql</filename> module has been
            configured as described in the <link linkend="extension-configuration">previous section</link>
            . </para>
          <programlisting language="xml" xml:space="preserve">
&lt;model behaviour="code"&gt; 
    &lt;param name="lang" value="@lang"/&gt; 
&lt;/model&gt;
        </programlisting>
        </section>
        <section xml:id="extension-modules-behaviour-parameters">
          <title>Custom Behaviours Accepting User-Defined Parameters</title>
          <para>Sometimes you may like to implement a generic behaviour which takes arbitrary
            parameters from the user. This means the parameter list of your behaviour will not be
            fixed.</para>
          <para> To facilitate this, a behaviour function may declare a final parameter <code>$optional
            as map(*)</code> . If the processor finds <tag>param</tag> children in the model which
            cannot be mapped to an explicitly declared parameter, it stores all such extra
            parameters as a key/value pairs in the <parameter>$optional</parameter> map. </para>
        </section>
      </section>


      <section xml:id="odd-by-example">
        <title>Building a Sample-Based ODD</title>
        <para> If you do not want to start a customized ODD from a blank template, you can
          alternatively generate one that covers the classes and elements of a selection of TEI
          files stored in TEI Publisher's data collection. Simply select one or more sample
          documents in the list to the left, enter a name and title into the form and click on <guibutton>Create
          from examples</guibutton> . Note that if you haven't removed the default examples TEI
          files that shipped with tei-publisher their markup will be included in the constructed ODD
          as well. </para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="BuildODD.gif" />
          </imageobject>
        </mediaobject>
        <para> This method uses the <filename>oddbyexample.xsl</filename> stylesheet that is part of
          the TEI consortium's <link xlink:show="new"
            xlink:href="https://github.com/TEIC/Stylesheets">stylesheets</link> . Users with a
          corpus of one or more TEI files can generate a custom odd that contains explicit additions
          and deletions for all possible TEI modules, as well as, <tag>valList</tag> for attribute
          values in the input corpus. </para>
        <para> By default the basis of the comparison for which elements have been modified in the
          examples is the full <filename>tei_all.odd</filename> . </para>
        <section xml:id="odd-by-example-advanced">
          <title>Advanced Use</title>
          <para> To further tweak the building process you can call the functions of the <filename>
            odd-by-example.xql</filename> module from your own XQuery code. If you wish to generate
            your own basis for the comparison you can call the following function to store a
            compiled ODD in the default odd location of tei-publisher: </para>
          <programlisting language="XQuery" xml:space="preserve">obe:compile-odd(doc('../odd/my-file.odd'), 'my-file-name')</programlisting>
          <note>
            <title>Note</title>
            <para> Due to a bug in the <filename>odd2odd.xsl</filename> stylesheet the output of
              this function is not always valid. To use it for further processing you need to make
              sure that only valid documents are used for further processing </para>
          </note>
          <para>You can also modify the transformation parameters of:</para>
          <programlisting language="XQuery" xml:space="preserve">obe:process-example(doc('../data/test/myTEI.xml'), 'odd-name', 'simplePrint')</programlisting>
          <para>The above example uses simplePrint as a basis for building the new ODD. The full
            list of configurable options are:</para>
          <programlisting language="xml" xml:space="preserve">&lt;parameters&gt;
  &lt;!-- the document corpus --&gt;
  &lt;param name="corpus" value="."/&gt;
  &lt;!-- name of odd --&gt;
  &lt;param name="schema" value="{substring-before($output, '.odd')}"/&gt;
  &lt;!-- the source of the TEI (just needs *Spec)--&gt;
  &lt;param name="defaultSource" value="{$base}"/&gt;
  &lt;!-- should we make valList for @rend and @rendition --&gt;
  &lt;param name="enumerateRend" value="false"/&gt;
  &lt;!-- whether to do all the global attributes --&gt;
  &lt;param name="keepGlobals" value="true"/&gt;
  &lt;!-- should elements in teiHeader be included?--&gt;
  &lt;param name="includeHeader" value="true"/&gt;
  &lt;!-- should we make valList for @type --&gt;
  &lt;param name="enumerateType" value="true"/&gt;
  &lt;!-- should we deal with non-TEI namespaces --&gt;
  &lt;param name="processNonTEI" value="false"/&gt;
  &lt;!-- do you want moduleRef generated with @include or @except? --&gt;
  &lt;!-- seems broken see https://github.com/TEIC/Stylesheets/issues/212 --&gt;
  &lt;param name="method" value="include"/&gt;
  &lt;!-- turn on debug messages --&gt;
  &lt;param name="debug" value="false"/&gt;
  &lt;!-- turn on messages --&gt;
  &lt;param name="verbose" value="false"/&gt;
  &lt;!-- which files to look at? provide suffix --&gt;
  &lt;param name="suffix" value="xml"/&gt;
  &lt;!-- should P4 files be considered? --&gt;
  &lt;param name="processP4" value="false"/&gt;
  &lt;!-- should P5 files be considered? --&gt;
  &lt;param name="processP5" value="true"/&gt;
&lt;/parameters&gt;
          </programlisting>
        </section>
      </section>
    </section>
  </section>
  <section xml:id="css-styling">
    <title>Custom CSS styling</title>

    <para> CSS stylesheet <code>resources/css/theme.css</code> defines styles used by all pages of
      the TEI Publisher and publisher-generated applications. Nevertheless, users <emphasis
        role="bold">should not</emphasis> directly modify this file but create a project-specific
      css customization file and include it alongside <code>theme.css</code> instead. </para>
    <programlisting language="html" xml:space="preserve">
                  &lt;link rel="stylesheet" href="resources/css/theme.css" /&gt;
                  &lt;link rel="stylesheet" href="resources/css/my-project.css" /&gt;
          </programlisting>
    <para> This approach allows to selectively overwrite certain styles and CSS variables from <code>
      theme.css</code> while remaining on the easy upgrade path for future TEI Publisher and <code>
      pb-components</code> updates. </para>

    <section xml:id="css-styling-components">
      <title>Customizing web components styling</title>
      <para>A web component completely shields its content, so it cannot be styled from outside. Web
        component styles remain encapsulated, preventing style contamination between individual
        components and general application context. A blessing in general, allowing components to be
        scripted and styled without the fear of collision with other parts of the page, but poses
        additional challenges when adjusting the look and feel of a component to fit a project's
        theme.</para>
      <para> For Publisher, encapsulation of web components means that definitions in <code>
        theme.css</code> or equivalent project customization CSS files are not able to directly
        govern web components styling. </para>
      <para> While some aspects of component styling remained unaccessible for customization in
        versions preceding Publisher 6, currently <code>pb-components</code> expose style properties
        to the outside world via standard CSS variables. This way variables like <code>
        --pb-footnote-color</code> defined in <code>theme.css</code> can be accessed by e.g. <code>
        pb-view</code> component and thus determine the color of the footnote marker in the rendered
        transcription. </para>

      <para>Note that while you cannot change the inner appearance of a component except by setting
        its custom CSS properties, you can style the component itself within the HTML template, e.g.
        to position it within the layout of the page.</para>
    </section>
    <section xml:id="css-styling-external">
      <title>External stylesheets</title>
      <para> ODD specification allows for explicit declaration of an external CSS file which may
        define styles and CSS classes to be applied to tranformed sources (in <code>
        encodingDesc/tagsDecl/rendition</code> ), e.g. </para>
      <programlisting language="xml" xml:space="preserve">
                  &lt;rendition source="docbook.css"/&gt;
          </programlisting>
      <para> Styles and classes from that file are loaded into <code>pb-view</code> component and
        thus accessible for its content. </para>
      <para> External stylesheets for <code>pb-view</code> can also be specified via <code>load-css</code>
        component configuration attribute. In this scenario, unlike with ODD <code>rendition</code>
        , regenerating the ODD is not required for changes to the CSS file to be applied, otherwise
        both methods are functionally equivalent. </para>

      <programlisting language="html" xml:space="preserve">
                  &lt;pb-view id="view1" src="document1" load-css="odd/docbook.css"/&gt;
          </programlisting>

      <para> Broader discussion of using <tag>rendition</tag> for custom styles can be found in <link
          linkend="external-css">this section</link> . </para>
      <!-- shall we discuss CSS shadow part? somewhere -->
    </section>
  </section>

  <section xml:id="webcomponents">
    <title>Page templates and pb-components</title>
    <para> As described earlier, the various sample documents included in the TEI Publisher Demo
      collection differ not only in the ODD they use, but also concerning the general layout and
      composition of the page. They are based on different HTML templates, which can be found in the <filename>
      templates/pages</filename> collection of the TEI Publisher app. Each template assembles
      various building blocks in a slightly different way - some <link linkend="selected-use-cases">
      examples</link> show a facsimile view next to the text, others a parallel display of
      transcription andtranslation, some include a map and another showcase collapsible metadata
      section. Which template is being used is determined by a <link linkend="pi-config">processing
      instruction</link> in the TEI sources of these examples. </para>
    <para>The building blocks we mentioned are custom HTML elements. Each of them encapsulates a
      certain functionality and appearance. The map, the facsimile, but also the text view itself
      and all controls are custom HTML elements. They are like "Lego" blocks which can be freely
      moved around and rearranged without knowing anything about internal implementation of the
      component.</para>
    <section xml:id="webcomponents-intro">
      <title>Web Components</title>


      <para> The technology enabling this Lego-like modular approach is a W3C standard called <emphasis>Web
        Components</emphasis> . It is already built into many browsers and support is improving
        quickly, reducing the need for external frameworks. There's a growing collection of
        ready-to-use components available, e.g. the <link xlink:show="new"
          xlink:href="https://www.webcomponents.org/author/PolymerElements">Polymer elements</link>
        we use for menus, buttons, dropdowns etc. TEI Publisher from version 6.0 exposes its
        collection of Web Components targeted at creating digital editions as a separate <code>
        pb-components</code> package. </para>
      <para> You do not need to know much about <emphasis>Web Components</emphasis> to use them in
        TEI Publisher. From a user perspective, a component looks like any other HTML element. You
        configure it by setting its properties via attributes. For example, the following HTML code
        snippet will display the first page/section of two completely different documents as you can
        see below in the embedded <link xlink:show="new" xlink:href="https://codepen.io/">Codepen</link>
        (to learn more on embedding Publisher output and components see <link linkend="embedding">further
        chapters</link> ) </para>
      <programlisting language="xml" xml:space="preserve">
&lt;pb-page&gt;
  &lt;pb-document id="document1" path="test/kant_rvernunft_1781.TEI-P5.xml" odd="dta" view="page"&gt;&lt;/pb-document&gt;
  &lt;pb-document id="document2" path="doc/documentation.xml" odd="docbook" view="div"&gt;&lt;/pb-document&gt;

  &lt;!-- Display two document views side by side --&gt;
  &lt;main&gt;
      &lt;pb-view id="view1" src="document1"&gt;&lt;/pb-view&gt;
      &lt;pb-view id="view2" src="document2"&gt;&lt;/pb-view&gt;
  &lt;/main&gt;
&lt;/pb-page&gt;</programlisting>

      <programlisting role="codepen" xlink:href="wolfgangmm#WNvYYWB" />
      <para>
        <tag>pb-page</tag> , <tag>pb-document</tag> and <tag>pb-view</tag> are three web components
        from <code>pb-components</code> library, while <tag>main</tag> is a standard HTML5 tag. The
        name of the custom element <emphasis role="bold">must</emphasis> start with a prefix to
        distinguish it from standard HTML. This concept should be familiar to XML people. For TEI
        Publisher components, the prefix is always <code>pb-</code> . Components from other sources
        will use different prefixes, e.g. <code>paper-</code> and <code>iron-</code> for the <emphasis>
        Polymer</emphasis> collection. </para>
      <para> The part of the page which uses TEI Publisher web components should always be wrapped
        into an <tag>pb-page</tag> element. This element determines the TEI Publisher server
        instance all other components will be communicating with (see the next section below). It is
        also responsible for some other initialization steps, e.g. loading the list of available
        user interface translations. . </para>
      <para>
        <tag>pb-document</tag> specifies a document source, which can then be referenced by id from
        other components. The component provides a way to configure basic properties governing
        document's default rendering, like associated ODD file, etc. In the example above, we define
        three properties for each document: </para>
      <variablelist>
        <varlistentry>
          <term>path</term>
          <listitem>
            <para> the relative path to the XML document. This will be interpreted as relative to
              the <emphasis>data root collection</emphasis> of TEI Publisher, by default pointing to
              the <filename>data</filename> collection within the TEI Publisher app. </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry>
          <term>odd</term>
          <listitem>
            <para> the name - without suffix - of the ODD to use for rendering the document. In the
              example, the first document is encoded in TEI and thus transformed through <filename>
              dta.odd</filename> , while the second is written in DocBook and passed through <filename>
              docbook.odd</filename> . </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry>
          <term>view</term>
          <listitem>
            <para>this property determines how the document will be paginated if the user navigates
              forward/backward. Currently three possible methods are available:</para>
            <orderedlist>
              <listitem>
                <para>
                  <parameter>div</parameter> : displays one structural division (TEI div, DocBook
                  section …) at a time </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>page</parameter> : displays the document page by page. This requires
                  page break indicators to be present ( <tag>pb</tag> in TEI, not supported for
                  docbook). </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>single</parameter> : the entire document (or a selected fragment of it)
                  is displayed at once </para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        <tag>pb-view</tag> is the critical component in TEI Publisher: it provides the actual text
        view by transforming a part or entirety of the source XML into HTML based on the processing
        model instructions in the ODD. </para>

      <para> Because webcomponents are all about encapsulation, <tag>pb-view</tag> ensures that the
        styling of the text as governed by the ODD will be confined to the boundaries of the
        component. This makes it possible to display two completely heterogenous texts (like the
        documentation and Kant's Kritik) on the same page without styles contaminating each other.
        As a downside, encapsulation also poses some challenges, which we discussed in the section
        about <link linkend="external-css">CSS styling</link> . </para>
    </section>

    <section xml:id="webcomponents-docs">
      <title>Webcomponent Documentation</title>
      <para> To better understand the various components TEI Publisher provides, it is best to have
        a look at the small examples contained in the <link xlink:show="new"
          xlink:href="https://cdn.tei-publisher.com/api.html">web
        components API documentation</link> . The list of components may be overwhelming at first
        sight. However you don’t need to learn them all. There are just a few components that should
        be understood before you start customizing. Their demo pages showcase a working example
        along with the code snippet which actually implements it. </para>
      <para> You can also get an editable live view like the one above if you click on the <guibutton>Edit
        Code</guibutton> button to the bottom right of each example. </para>
      <para>In particular you may want to look at the following examples:</para>
      <variablelist>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="https://cdn.tei-publisher.com/api.html#pb-document.1">
            pb-document</link>
          </term>
          <listitem>
            <para>shows the example given above in action</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="https://cdn.tei-publisher.com/api.html#pb-view.1">
            pb-view</link>
          </term>
          <listitem>
            <para>adds navigation buttons to read the document page by page</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="https://cdn.tei-publisher.com/api.html#pb-facsimile.1">
            pb-facsimile</link>
          </term>
          <listitem>
            <para>display facsimiles via IIIF server and link to them</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="https://cdn.tei-publisher.com/api.html#pb-leaflet-map.1">
            pb-leaflet-map</link>
          </term>
          <listitem>
            <para>show a map and link to geo coordinates</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="https://cdn.tei-publisher.com/api.html#pb-load.1">
            pb-load</link>
          </term>
          <listitem>
            <para>call a server-side XQuery to retrieve additional information about the document,
              in this case actors appearing in the play</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="https://cdn.tei-publisher.com/api.html#pb-search.1">
            pb-search</link>
          </term>
          <listitem>
            <para>execute a search on the database, retrieve the results and paginate through them</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="https://cdn.tei-publisher.com/api.html#pb-grid.1">
            pb-grid</link>
          </term>
          <listitem>
            <para>dynamically add more columns to a horizontal grid of components</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <note>
        <title>Caveat</title>
        <para> Some properties of pb-view and other components are boolean properties. In HTML5 this
          corresponds to an attribute without value, which is illegal in XML. If you want to
          preserve valid XML, just write the attribute with the same name and value, e.g. <code>
          append-footnotes="append-footnotes"</code> . </para>
      </note>
    </section>

    <section xml:id="webcomponents-communication">
      <title>Communication between Components</title>
      <para> To allow for maximum flexibility, nearly all of the TEI Publisher webcomponents
        communicate via events: this way avoids hard wiring and components may appear anywhere on
        the page. For example, the controls for paginating through a document do not directly talk
        to the document view: they just send an <emphasis>event</emphasis> , indicating the users'
        wish to navigate backward or forward. Components listening for this event may then react to
        it by refreshing the text being displayed. </para>
      <para> Since you can have multiple text views showing content from different sources, every
        event can be announced at a specific communication <emphasis>channel</emphasis> . This
        allows us to distinguish between different sources, e.g. two transcriptions being shown side
        by side. Most TEI Publisher components therefore accept two properties to configure the
        channel they are listening or sending events to: </para>
      <variablelist>
        <varlistentry>
          <term>subscribe</term>
          <listitem>
            <para>name of the channel to which this component subscribes to. It will only react to
              events coming in via this channel.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>emit</term>
          <listitem>
            <para>name of the channel to which this components sends events.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>If neither of these properties is given, the component will subscribe and emit to the
        global default channel. A component may also send to a different channel than it subscribes
        to, allowing chains of events.</para>
      <para>Common properties and methods accepted by many TEI Publisher components are defined in
        the class PbMixin.</para>
    </section>

    <section xml:id="webcomponents-page-templates">
      <title>Page Templates</title>
      <para> TEI Publisher currently includes several different page templates, which combine the
        building blocks described above with off-the-shelf components to achieve a certain page
        layout and composition. If you look at the HTML code, you'll see a mix of <parameter>pb-</parameter>
        elements and <parameter>app-</parameter> , <parameter>paper-</parameter> , <parameter>iron-</parameter>
        elements. The last three belong to the <emphasis>Polymer</emphasis> collection and you can
        find them documented in the public <link xlink:href="https://www.webcomponents.org/">webcomponent
        registry</link> . TEI Publisher components are not yet available there, though we may move
        some of the general purpose components there later. </para>
      <para>To avoid redundancy, the page template files use eXist's templating feature to drag in
        some repeating parts which are the same for all pages, for example, the toolbar and the
        menu. You'll find these files in the corresponding sub-collection:</para>
      <programlisting xml:space="preserve">&lt;app-toolbar data-template="lib:include" data-template-path="templates/menu.html"/&gt;
&lt;app-toolbar data-template="lib:include" data-template-path="templates/toolbar.html"/&gt;</programlisting>
      <para>The following page templates are currently available in TEI Publisher:</para>
      <variablelist>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/view.html" role="source">view.html</link>
          </term>
          <listitem>
            <para>the default template showing a single text view at the center</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/facsimile.html" role="source">facsimile.html</link>
          </term>
          <listitem>
            <para>a template featuring a facsimile view to the right, retrieving images from a IIIF
              server</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/letter.html" role="source">letter.html</link>
          </term>
          <listitem>
            <para>used for Graves' letter, this template displays an additional map to the right and
              a list of places, people and organizations</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/translation.html" role="source">translation.html</link>
          </term>
          <listitem>
            <para> shows a transcription and its translation side by side. Both are contained in the
              same TEI document and extracted via an XPath expression passed to <tag>pb-view</tag>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/cortez-with-translation.html" role="source">
            cortez-with-translation.html</link>
          </term>
          <listitem>
            <para> similar to <filename>translation.html</filename> but the alignment between
              transcription and translation is more complex as the translation contains no page
              breaks. The part of the translation corresponding to a given fragment of the
              transcription thus needs to be computed dynamically for each page, using an XQuery
              function (defined by the <parameter>map</parameter> on <tag>pb-view</tag> . </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/cortez" role="source">cortez.html</link>
          </term>
          <listitem>
            <para>like above but with additional facsimile panel</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/vangogh.html" role="source">vangogh.html</link>
          </term>
          <listitem>
            <para>demonstrates three columns by default: a metadata column, a transcription which
              can be switched to a diplomatic view including line endings, and a translation. Other
              columns, e.g. facsimile or commentary can be added dynamically.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/dantiscus.html" role="source">dantiscus.html</link>
          </term>
          <listitem>
            <para> builds upon <code>facsimile.html</code> adding a collapsible <code>pb-drawer</code>
              element to display metadata from <emphasis>teiHeader</emphasis> section. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/osinski.html" role="source">osinski.html</link>
          </term>
          <listitem>
            <para> similarly builds upon <code>facsimile.html</code> but a collapsible metadata
              section is realized with a <code>pb-collapse</code> element. </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <note>
        <title>Important Note</title>
        <para>The page templates are meant as examples to be copied and modified by users. They were
          written to match the concrete example and do not intend to be universal. TEI is too
          heterogenous to provide a one-size-fits-all solution. We thus believe that providing a
          wide range of practical examples is the best way to help users realize their own project.</para>
        <para> Only the generic template, <filename>view.html</filename> should work with all
          example TEI documents. </para>
      </note>
    </section>

    <section xml:id="customizing-page-template">
      <title>Create your own Template</title>
      <para>To create your own template</para>
      <orderedlist>
        <listitem>
          <para>open one of the existing templates in e.g. eXide (by clicking the links in the list
            above)</para>
        </listitem>
        <listitem>
          <para> adjust <code>content</code> attribute in <code>meta</code> tag to a label that fits
            your template </para>
          <programlisting language="html" xml:space="preserve">
                  &lt;meta name="description" content="XYZ edition project" /&gt;
              </programlisting>

        </listitem>
        <listitem>
          <para> save the file under a different name into the same collection ( <filename>
            templates/pages</filename> ) </para>
        </listitem>
      </orderedlist>

      <para>Now reload the document you'd like the template to apply to and you'll be able to switch
        to your new template, either by</para>


      <itemizedlist>
        <listitem>
          <para> using the <guibutton>Template</guibutton> dropdown in the <guibutton>Settings</guibutton>
            panel </para>
        </listitem>
        <listitem>
          <para> adding a parameter <parameter>template=mytemplate.html</parameter> to the URL
            showed by the browser </para>
        </listitem>
        <listitem>
          <para> adding a <link linkend="pi-config">processing instruction</link> to a TEI document
            to make a specific template the default: </para>
          <programlisting language="html" xml:space="preserve">&lt;?teipublisher template="translation.html" odd="dantiscus.odd" view="page"?&gt;</programlisting>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="alignment">
      <title>Handling Complex Alignments</title>
      <para> It is often desirable to show two or more views of a document at the same time, for
        example to display the translation aligned with a given source fragment. In the simplest
        case, the transcription and translation may be aligned on the level of divisions or page
        breaks and one can simply use two <tag>pb-view</tag> referencing different starting points
        in the TEI document (this approach is implemented by the <link
          xlink:href="templates/pages/translation.html" role="source">translation.html</link>
        template for Serafin's letter). </para>
      <para>Unfortunately things are not always as simple as that. For example, even if the
        transcription contains page breaks or milestones which can be used to display a single page,
        the translation might not. One thus needs a different approach to compute the alignment
        between fragments. Nevertheless, the logic of the alignment algorithm will highly depend on
        the conventions used in the encoding. TEI allows a wide variety of alignment mechanisms and
        we do not want to limit the freedom of the editor by prescribing a particular method.</para>
      <para>TEI Publisher thus implements a generic way to plug an XQuery function into the
        processing pipeline. The function takes the source element being processed as input and may
        replace it by its aligned equivalent. Such an equivalent may be another element or fragment
        from the same or a different document. The source element will usually point to the part of
        the transcription being displayed. The mapping function uses this as starting point to
        determine an aligned fragment and returns it. The returned fragment will then be further
        passed through the processing model.</para>
      <para> The XQuery mapping function should be defined in the module <filename>modules/map.xql</filename>
        . It takes an element as its only argument and may return any valid TEI fragment, which will
        become the input for futher processing through the processing model. </para>
      <para> The local name of the mapping function can then be supplied in the attribute <parameter>
        map</parameter> of <tag>pb-view</tag> . As an illustration, the Van Gogh example includes
        the following <code>pb-view</code> for displaying the translation: </para>
      <programlisting language="xquery" xml:space="preserve">&lt;pb-view src="document1" map="vg-translation" xpath="//div[@type='original']"
    subscribe="transcription"/&gt;</programlisting>
      <para> In the Van Gogh letters, the translation contains page breaks corresponding to page
        breaks in the original letter, but these are using a different prefix for the <code>xml:id</code>
        . To align the translation with the transcription, we only need to adjust the id, and
        retrieve the corresponding page break to be done. The XQuery mapping function is thus rather
        simple: </para>
      <programlisting language="xquery" xml:space="preserve">declare function mapping:vg-translation($root as element()) {
    let $id := ``[pb-trans-`{$root/@f}`-`{$root/@n}`]``
    let $node := root($root)/id($id)
    return
        $node
};</programlisting>
      <para> Note that returning the corresponding <tag>pb</tag> node of the translation is
        sufficient here as further processing will automatically extract the page fragment up to the
        next <tag>pb</tag> . More complex cases may require that mapping function returns arbitrary
        TEI fragment. Also note that the <parameter>xpath</parameter> attribute of the <tag>pb-view</tag>
        element in the template must still point to the source transcription ( <parameter>
        div[@type='original']</parameter> in this case). It's just the mapping function which
        translates a position in the source transcription to a corresponding fragment in the
        translation. </para>
      <para>The letter by Cortez to Dantiscus sent from Mexico demonstrates a much more
        sophisticated alignment, determining the translation fragment to be shown by inspecting the
        ID range of the transcription. It illustrates the case where no milestone elements exist in
        the translation to explicitly mark page boundaries of the original, thus mapping algorithm
        aims to display closest corresponding fragment of the translated text.</para>
    </section>
  </section>

  <section xml:id="api">
    <title>Server-side API</title>
    <para> Many of the user interface web components need to communicate with the server to request
      certain data to be retrieved, processed and returned before the client-side components can
      display it to the user. For example, when user clicks the <guibutton>Table of Contents</guibutton>
      button, the corresponding <parameter>pb-load</parameter> component sends an ajax request to
      retrieve the list of chapters. Similarly, when user types something in the autocomplete field,
      a request is sent after each keystroke to find matching terms in the index. These requests
      need to be received and processed by the server with the eXist instance running and only then
      data will be returned to the browser. </para>

    <para> Previous versions of the TEI Publisher included a number of XQuery modules implementing
      the server-side functionality, located in <parameter>modules</parameter> collection. In
      version 7, a new approach has been introduced. Formal <link xlink:href="../api.html"
        xlink:show="new">API specification</link> , based on the <link xlink:show="new"
        xlink:href="http://spec.openapis.org/oas/v3.0.3">Open API standard</link> defines all the
      server-side API endpoints available in Publisher. </para>

    <para>The image below presents a section of the API handling all ODD-related operations:
      creating, retrieving, updating, deleting, recompiling; syntax check for a code fragment
      (lint); retrieving a list of all available ODDs.</para>

    <figure>
      <title>TEI Publisher API page - the odd endpoint</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="api-spec.png" width="900px" />
        </imageobject>
      </mediaobject>
    </figure>

    <section xml:id="api-advantages">
      <title>Advantages of the API-based approach</title>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">clear specification and easy overview</emphasis>
          </para>
          <para>users and developers will benefit from the clear specification for available
            functionality</para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">customizable</emphasis>
          </para>
          <para>users can easily overwrite and extend existing API endpoints as well as add custom
            ones for project-specific functionality</para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">separation of concerns</emphasis>
          </para>
          <para>server-side functionality can be used directly by any software system, not
            necessarily within the context of the TEI Publisher or using Publisher's UI components;
            further changes in internal API implementation do not require any adjustments of the UI
            components</para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">standard-based</emphasis>
          </para>
          <para>OAS compliance means we are using a well-known and documented standard and can
            benefit from existing tools for writing, testing and generating documentation</para>
        </listitem>
      </itemizedlist>
    </section>

    <!-- <section xml:id="api-examples">
      <title>Examples</title>
      <para>pb-autocomplete, pb-load, pb-view </para>
    </section>-->
    <section xml:id="api-endpoints">
      <title>API endpoint groups</title>
      <para>TEI Publisher 7 groups server-side functionality into several main sections:</para>
      <variablelist>
        <varlistentry>
          <term>documents</term>
          <listitem>
            <para>Retrieve entire or part of a document content transformed to a target format;
              retrieve document's table of contents; delete a document.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>collection</term>
          <listitem>
            <para>Browse the collection hierarchy and upload new files.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>odd</term>
          <listitem>
            <para>Manage the ODD files stored in TEI Publisher: create, retrieve, update, delete,
              recompile; check syntax for a code fragment (lint); retrieve a list of available ODDs.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>search</term>
          <listitem>
            <para>Search: run a search through collections; list facets for the search results; list
              autocomplete options.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>transform</term>
          <listitem>
            <para>Transform content on the fly: convert a Word document to TEI or POST an XML
              document and get its preview rendered via ODD.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>view</term>
          <listitem>
            <para>View documents via an HTML template; list available templates.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>apps</term>
          <listitem>
            <para> Operations for managing apps: generate a standalone application or package and
              download an app.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>dts</term>
          <listitem>
            <para> Implementation of the DTS (Distributed Text Services) API.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>user</term>
          <listitem>
            <para>Login: authorize the user.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>info</term>
          <listitem>
            <para>Information about the server: the API version.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <!-- Backwards compatibility (perhaps
      belongs to the web components discussion) -->
    </section>
    <section xml:id="api-custom-endpoints">
      <title>Custom API endpoints</title>
      <para> Beyond the standard server-side functionality provided by TEI Publisher, careful
        provisions have been made to allow users to add their own API endpoints. The <link
          xlink:href="../api.html#operations-tag-default" xlink:show="new">Custom API</link> section
        demonstrates how project-specific functionality can be added within the OAS API scheme. </para>
      <para> All that is required is to edit the <filename>modules/custom-api.json</filename> file
        and add specifications for custom endpoints in JSON format. The <parameter>operationId</parameter>
        property specifies the XQuery function to be called to process the request. All function
        module with the function definition needs to be imported into <filename>
        modules/custom-api.xql</filename> so that the request can be correctly resolved. </para>
      <para> The function implementation can either be added to the XQuery module <filename>
        modules/custom-api.xql</filename> or to a new module, which should be imported into this
        file to make it known. See the <link xlink:show="new"
          xlink:href="https://github.com/eeditiones/oas-router">README</link> of the oas-router
        package for more information about how to write a request handler function. </para>
      <figure>
        <title>Custom API specification - show article</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="api-custom-json.png" width="900px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> To reference a custom function declared directly in <filename>modules/custom-api.xql</filename>
        , use the prefix <parameter>custom:</parameter> in the <parameter>operationId</parameter> .
        For functions in imported modules, use the prefix defined in the import statement. </para>
    </section>
  </section>

  <section xml:id="i18n">
    <title>Language versions</title>
    <para>TEI Publisher is already available in twenty languages and this number increases thanks to
      the engagement of our user community.</para>

    <para>With version 6.0 i18n support has been greatly extended to cover not only labels and
      attribute values in HTML templates but also within web components. A mechanism for project
      specific language files extending the default Publisher label collection has been added.</para>
    <para> Thanks to community contributions via <link xlink:href="https://crwd.in/tei-publisher">
      Crowdin</link> a number of languages has been added and existing ones are updated when needed.
      We welcome and encourage additions and amendments. Please consider Crowdin a master repository
      for translations and publish your contributions there instead of submitting PR directly. Do
      not hesitate to get in touch if a language you'd like to support is not yet listed. </para>
    <para> Crowdin users are only exposed to form-based graphical user interface but i18n files are
      using JSON format to preserve their logical structure. Initial portion of German localization
      file <filename>de.json</filename> is shown below for illustration. </para>
    <figure>
      <title>Translation JSON file structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="i18n-json-structure.png" />
        </imageobject>
      </mediaobject>
    </figure>
    <para> In TEI Publisher and in generated apps translation files are by default loaded from CDN
      with <code>pb-components</code> . When it is necessary for a project to add new labels or
      change wording of existing ones, a customization mechanism is described <link
        linkend="i18n-customization">below</link> . </para>
    <section xml:id="i18n-page-templates">
      <title>Using i18n in page templates</title>
      <para>There are several scenarios for using i18n labels:</para>
      <itemizedlist>
        <listitem>
          <para>directly within HTML element</para>
        </listitem>
        <listitem>
          <para>in an attribute</para>
        </listitem>
        <listitem>
          <para>passed in component-specific structure</para>
        </listitem>
      </itemizedlist>
      <section xml:id="i18n-page-templates-pb-i18n">
        <title> HTML text node with <code>pb-i18n</code>
        </title>
        <para> Any text fragment within HTML element can be considered a target for i18n when
          wrapped in <tag>pb-i18n</tag> component. <tag>pb-i18n</tag> elements are listening for
          events emitted by <tag>pb-lang</tag> . </para>
        <programlisting language="html" xml:space="preserve">
&lt;h3 slot="collapse-trigger"&gt;
   &lt;pb-i18n key="menu.documentation"&gt;Documentation&lt;/pb-i18n&gt;
&lt;/h3&gt;
        </programlisting>
      </section>
      <section xml:id="i18n-page-templates-attributes">
        <title>Attributes (on HTML elements or custom web components)</title>
        <para> When it is necessary to translate the value of an attribute a mechanism based on <code>
          data-</code> attributes is used. Supply additional <code>data-i18n</code> attribute
          specifying the key of the i18n label to use preceded by the name of the attribute that
          needs to be translated. In the example below it's the <code>heading</code> attribute that
          needs to be filled with the translated version of <emphasis>ODD Files</emphasis> label.
          The label is stored in JSON file under <code>odd.files</code> , so <code>
          [heading]odd.files</code> needs to be used for the <code>data-i18n</code> attribute. </para>
        <programlisting language="xml" xml:space="preserve">
&lt;paper-card data-i18n="[heading]odd.files" class="odds" heading="ODD Files"&gt;
   &lt;div class="card-content"&gt; ... content of the ODD list &lt;/div&gt;
&lt;/paper-card&gt;
        </programlisting>
        <para> When <tag>pb-lang</tag> is switched to Spanish, the <tag>paper-card</tag> heading
          will read <emphasis>Archivos ODD</emphasis> instead of <emphasis>ODD Files</emphasis> . </para>
        <figure>
          <title> Output for <tag>paper-card</tag> with translated <code>@heading</code>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="i18n-attribute.png" width="300px" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section xml:id="i18n-page-templates-properties">
        <title>Special web component properties configured via attributes</title>
        <para> Some web components accept more complex configuration options via arrays passed in
          attributes. For example, <tag>pb-browse-docs</tag> component allows to specify a number of
          label/value pairs for dropdown menus used for ordering and filtering the document list.
          Understandably, the labels should switch in line with changes to the language chosen via <tag>
          pb-lang</tag> . Therefore i18n translation keys like <emphasis>browse.title</emphasis> or <emphasis>
          browse.author</emphasis> are used instead of text values. Note that web components may
          have particular expectations for the data format expected so consult API documentation for
          each component. </para>
        <programlisting language="html" xml:space="preserve">
&lt;pb-browse-docs id="document-list" url="collection/" 
      sort-options='[{"label": "browse.title", "value": "title"},{"label": "browse.author", "value": "author"}]' 
      sort-by="title"
      filter-options='[{"label": "browse.title", "value": "title"},{"label": "browse.author", "value": "author"},{"label": "browse.file", "value": "file"}]' 
      filter-by="title" 
      auto="auto" history="history" login="login" emit="docs" subscribe="docs"&gt;
  &lt;pb-paginate slot="toolbar" id="paginate" per-page="10" range="5" emit="docs" subscribe="docs"&gt;&lt;/pb-paginate&gt;
&lt;/pb-browse-docs&gt;
         </programlisting>
      </section>
    </section>

    <section xml:id="i18n-customization">
      <title>Project specific i18n files</title>
      <para>It is a common need that projects will need their own internationalized labels for menu
        items, dialogs and other user interface elements.</para>
      <para>All these can be stored in JSON language files, following the same naming conventions
        and basic structure as TEI Publisher ones. To use custom language files, you need to specify
        the path under which they can be found relative to your application:</para>
      <programlisting language="html" xml:space="preserve">&lt;pb-page locales="resources/i18n/{{ns}}/{{lng}}.json"&gt;</programlisting>
      <para> The path expression requires placeholders for two parameters <parameter>ns</parameter>
        and <parameter>lng</parameter> : </para>
      <variablelist>
        <varlistentry>
          <term>lng</term>
          <listitem>
            <para> the language code for a selected language, e.g. <code>de</code> or <code>fr</code>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ns</term>
          <listitem>
            <para> the namespace prefix used to distinguish between different collections of
              language files. By default, TEI Publisher expects custom language files to be in a
              namespace called <code>app</code> , though this can be configured. </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para> So given above configuration, TEI Publisher will search for a custom language file for,
        say, French in <code>resources/i18n/app/fr.json</code> . If you prefer a flat directory
        structure, you could change the <parameter>locale</parameter> to <code>
        resources/i18n/{{ns}}_{{lng}}.json</code> and TEI Publisher will look for a file <code>
        resources/i18n/app_fr.json</code> . </para>
      <para> You may also define additional namespaces to be searched with the <parameter>
        locale-fallback-ns</parameter> parameter: </para>
      <programlisting language="html" xml:space="preserve">&lt;pb-page locales="resources/i18n/{{ns}}/{{lng}}.json"
        locale-fallback-ns="app my-module"&gt;</programlisting>
      <para> which means that TEI Publisher will search for labels in the <code>my-module</code>
        namespace first, then falling back to the <code>app</code> namespace, and if the label could
        still not be found, using TEI Publisher's default namespace. The latter is called <code>
        common</code> and should not be overwritten. </para>
      <para> Listing below demonstrates a fictional <filename>en.js</filename> with a custom set of
        labels. A new top-level key has been added as well as 3 subkeys for the <code>menu</code>
        section. Now the project has access to a number of new i18n keys: <code>menu.about</code> , <code>
        menu.contact</code> , <code>menu.statute</code> and <code>greeting</code> . </para>
      <para> Furthermore, a value for <code>menu.documentation</code> has been specified. That key
        already existed in Publisher (set to "Documentation") but the version from custom file will
        take precedence and be used in the custom app. </para>
      <programlisting language="js" xml:space="preserve">
{
  "menu": {
    "documentation": "Docu",
    "about": "About",
    "contact": "Contact",
    "statute": "Statute"
    },
  "greeting": "Welcome"
}
      </programlisting>
      <para />
    </section>
  </section>

  <section xml:id="appgen">
    <title>Creating applications with the App Generator</title>
    <para>Once you are happy with a certain ODD and HTML template customization, you can easily
      create a complete, standalone application. Such application can be tailored further to fit
      your needs. The generated app can be downloaded as a portable xar package, to be installed
      into other eXist instances, or synchronised to disk for further development. It provides a
      fully functional application scaffolding based on TEI Publisher components and modules,
      pre-configured to use a certain ODD, page template and other settings.</para>
    <note>
      <title>Note</title>
      <para>Early versions of the TEI Publisher included everything they needed to run without TEI
        Publisher. This had some advantages, but also made it more difficult to update to newer
        releases.</para>
      <para> Starting with version 5 we are gradually moving towards more lightweight app design,
        ultimately containing only resources which are truly specific to the app (ODDs, HTML
        templates, images), while all generic functionality will be provided by TEI Publisher and
        its libraries and packages. Version 6 has seen all web components extracted into <code>
        pb-components</code> package and in version 7 the server-side code has been based on a well
        designed API specification with provisions for easy customization. <!--TEI
        Publisher itself will get an app administration page, which will allow users to
          manage and customize all installed apps from a central management shell.-->
      </para>
      <para> Please make sure you are following our <link linkend="customization-best-practice">best
        practice recommendations</link> for a smooth upgrade path. </para>
    </note>
    <para> To get started, click on <guimenuitem>App Generator</guimenuitem> in the menu bar and
      fill out the form. </para>

    <para>The following form fields are of particular importance:</para>
    <variablelist>
      <varlistentry>
        <term>ODD</term>
        <listitem>
          <para>Here you select the ODD(s) to be used for transformations. If multiple ODDs are
            selected, the first one will be the default.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>URL to identify the app</term>
        <listitem>
          <para>This is the main identifier for your app and should be a globally unique URI. It
            does not need to correspond to any existing web site. eXist's package manager is using
            this URI as a unique identifier for the app.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Abbreviation</term>
        <listitem>
          <para>The abbreviation will be used as the name of the root collection of your app and as
            the last path component in any URL pointing to the app. It should be unique within one
            database instance.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Template</term>
        <listitem>
          <para>The HTML template to be used as default for viewing a document. If you created a
            custom template or modified any of the existing templates, you likely want to select
            this here.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Data Collection</term>
        <listitem>
          <para>Only specify something here if you have existing data inside the database or if you
            want to ship the data set as part of a second, separate app. In all other cases, leave
            this field empty.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Default View</term>
        <listitem>
          <para> Default document view - whole document, page by page or division by division. If
            you would like to choose page by page, set this to <guimenuitem>"By Page"</guimenuitem>
            but please note that all your documents must be appropriately encoded with page breaks
            as <tag>pb</tag> elements. You will still be able to change the view settings in HTML
            template or users can do it via query parameters. </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>User/Password</term>
        <listitem>
          <para>The user account which will own all application files. For security reasons, it is
            advisable to create a new account for every app.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>Once you created the new application, log into it using the account details you provided.
      You can then upload XML documents using the upload panel in the sidebar.</para>
    <figure xml:id="create-app">
      <title>Create an App</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="CreateApp.gif" />
        </imageobject>
      </mediaobject>
    </figure>
    <section xml:id="appgen-code-overview">
      <title>Generated Code Overview</title>
      <section xml:id="appgen-code-overview-xquery">
        <title>XQuery Code</title>
        <para> The collection structure of the generated app follows typical design of many eXist
          apps. <link linkend="customization-best-practice">Best practices</link> for modifying the
          app are discussed in further sections of this document. You can find the code of your
          generated app within the <filename>/db/apps</filename> collection under the name you
          provided in the <emphasis>abbreviation</emphasis> field of the generator form. </para>
        <variablelist>
          <varlistentry>
            <term>modules</term>
            <listitem>
              <para> Contains XQuery modules used by the app, including the copied TEI Publisher
                libraries in <filename>modules/lib</filename> subcollection. </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>resources</term>
            <listitem>
              <para> Contains a number of subcollections for various resources used by the app, such
                as images, fonts or JavaScript libraries. Of particular interest is the <filename>
                resources/odd</filename> subcollection where app's own ODD files are stored. </para>
              <para> All of the app styling is done via a set of modularized less stylesheets,
                residing in <filename>resources/css</filename> . The main file is <filename>
                style.less</filename> , which defines a number of core parameters. Ideally this
                should be the only file you ever need to modify. </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>templates</term>
            <listitem>
              <para>Html templates for the templating framework. Contain page templates as well as
                smaller components such as menu or login pane.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>transform</term>
            <listitem>
              <para>This collections contains XQuery modules governing the transformations and
                styles generated from app's ODD. Its content will be overwritten with each ODD
                recompilation, thus there's no point modifying it. It's worth consulting though to
                gain better understanding and troubleshoot the transformations with TEI Processing
                Model. In case of an issue, it may help to know the files: </para>
              <variablelist>
                <varlistentry>
                  <term>{myodd}-web.xql</term>
                  <listitem>
                    <para>The transformation module generated for output mode "web".</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>{myodd}-web-module.xql</term>
                  <listitem>
                    <para>Library module which calls the transformation module.</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>{myodd}.css</term>
                  <listitem>
                    <para>CSS styles generated from the ODD.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
              <para>Files start with the name of the odd and the output mode they belong to.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <section xml:id="appgen-modify">
      <title>Modifying the App</title>
      <para> When you are logged in, the <guibutton>Admin</guibutton> menu in the top navbar
        provides various links for ease of customization of your app: </para>
      <variablelist>
        <varlistentry>
          <term>Recompile ODD</term>
          <listitem>
            <para>After changing the application's ODD, click here to update the app.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Edit ODD</term>
          <listitem>
            <para>Opens the application's ODD in eXide for editing.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <section xml:id="multiple-odds">
        <title>Using Multiple ODDs</title>

        <para>For performance reasons, the mechanism used by generated apps to transform a document
          via an ODD is slightly different to the one in the main TEI Publisher app: while TEI
          Publisher resolves ODDs dynamically, generated apps use a static lookup method. </para>
        <para>The static method is much faster, resulting in better overall performance, but as a
          consequence ODDs are not automatically detected by the app, and need to be explicitly
          registered.</para>
        <para> Each generated app will by default use a single ODD for all transformations but it is
          possible to add additional ODDs, e.g. to be used with a <code>pb-view</code> in a custom
          HTML template. If multiple ODDs are selected when generating the app, the app generator
          will take care of registering those ODDs. If you would like to add ODDs manually later,
          the procedure is as follows: </para>
        <procedure>
          <step>
            <para> Upload the ODD to the <filename>resources/odd</filename> collection below your
              app root. This can either be done via <emphasis>eXide</emphasis> or the <guibutton>
              Upload</guibutton> panel on the start page of your app. </para>
          </step>
          <step>
            <para> In <filename>modules/config.xqm</filename> find the variable called <parameter>
              $config:odd-available</parameter> and add the name of the new ODD to the sequence. </para>
            <programlisting language="xquery" xml:space="preserve">(:~
 : The main ODD to be used by default
 :)
declare variable $config:default-odd :="shakespeare.odd";

(:~
 : Complete list of ODD files used by the app. If you add another ODD to this list,
 : make sure to run modules/generate-pm-config.xql to update the main configuration
 : module for transformations (modules/pm-config.xql).
 :)
declare variable $config:odd-available :=("shakespeare.odd");</programlisting>
          </step>
          <step>
            <para> In eXide, open <filename>modules/generate-pm-config.xql</filename> (path relative
              to your app root) and execute it once. This will regenerate the XQuery module <filename>
              modules/pm-config.xql</filename> , which registers all the ODD modules known to the
              app. </para>
          </step>
          <step>
            <para>Additionally you need to regenerate all ODDs used by the app by either</para>
            <orderedlist>
              <listitem>
                <para> Clicking the <guibutton>Regenerate all ODDs</guibutton> button on the start
                  page of the app </para>
              </listitem>
              <listitem>
                <para> Via the api documentation page <filename>api.html</filename> by executing the <parameter>
                  POST</parameter> version of the <code>/api/odd</code> . </para>
              </listitem>
            </orderedlist>
          </step>
        </procedure>
        <section xml:id="multiple-odds-collection">
          <title>Using different ODDs depending on the collection</title>
          <para> By default the same ODD will be used for all documents within the app. It is
            possible though to organize documents into a <link linkend="subcollections">hierarchy of
            collections</link> beneath <parameter>$config:data-root</parameter> and use different
            ODDs and general view settings for each collection or document type. </para>
          <para> To do so, search for the function <function>config:collection-config</function> ,
            which by default returns an empty sequence - meaning that the default configuration
            should be used. Comment this out and enable the switch/case statement below to return a
            different config depending on the current collection. The <parameter>$collection</parameter>
            and <parameter>$docUri</parameter> parameters be relative paths, i.e. relative to <parameter>
            $config:data-root</parameter> . So for a single level hierarchy as used in TEI Publisher
            by default, <parameter>$collection</parameter> will be either <code>test</code> , <code>
            playground</code> or <code>doc</code> . For multi-level hierarchies it might also be
            e.g. <code>volume1/transcripts</code> . In this case a simple switch/case might not be
            enough, but you can just replace it with an if/then/else and apply any path matching you
            like. </para>

          <programlisting language="xquery" xml:space="preserve">
declare function config:collection-config($collection as xs:string?, $docUri as xs:string?) {
    (: Return empty sequence to use default config :)
    ()

    (: 
     : Replace line above with the following code to switch between different view configurations per collection.
     : $collection corresponds to the relative collection path (i.e. after $config:data-root). 
     :)
    (:
    switch ($collection)
        case "playground" return
            map {
                "odd": "dodis.odd",
                "view": "body",
                "depth": $config:pagination-depth,
                "fill": $config:pagination-fill,
                "template": "facsimile.html"
            }
        default return
            ()
    :)
};
          </programlisting>
          <para>Instead of switching by collection, you could also configure different views
            depending on the type of document, e.g. by checking the type of the first div: </para>
          <synopsis language="xquery">doc($config:data-root || "/" || $docUri)//tei:body/tei:div/@type</synopsis>
        </section>
      </section>
    </section>

    <section xml:id="appgen-export">
      <title>Exporting the Finished App</title>
      <para> To save your finished application or exchange it with other people, you need to save it
        as an application archive. Application archives use a standardized <link xlink:show="new"
          xlink:href="https://exist-db.org/exist/apps/doc/repo#expath-pkg">EXPath Packaging</link>
        format: the resulting <filename>.xar</filename> file can be uploaded to any eXist instance
        via the <guibutton>Dashboard</guibutton> and the <guibutton>Package manager</guibutton> will
        take care of the deployment. </para>
      <para> There are two ways to create a <filename>.xar</filename> file from your application: </para>
      <orderedlist>
        <listitem>
          <para> Use the <guibutton>Admin </guibutton> / <guibutton>Download App</guibutton> menu
            entry in generated app to directly download a <filename>.xar</filename>
          </para>
        </listitem>
        <listitem>
          <para> Synchronize the application to a directory on disk via <guibutton>Application</guibutton>
            / <guibutton>Synchronize</guibutton> in <emphasis role="bold">eXide</emphasis>
          </para>
        </listitem>
      </orderedlist>
      <para> The first approach is recommended if all you need is a copy of you app on disk. A <filename>
        .xar</filename> is just a ZIP archive, so you can unpack it into a directory of your choice,
        which you can then commit to a version control system like git. </para>
      <para>However, if you continue to make changes inside the database (e.g. further work on the
        ODD), you may want to use the second method, i.e. call eXide's synchronization. It requires
        that you have access to the file system of the server running eXist though, so it's usually
        only an option if you run your own eXist instance locally. The synchronize steps in detail:</para>
      <itemizedlist>
        <listitem>
          <para> Prerequisite: you need to have the <link xlink:show="new"
              xlink:href="http://ant.apache.org/">Apache Ant</link> build tool installed. </para>
        </listitem>
        <listitem>
          <para> Open one resource belonging to your application in eXide. It doesn't matter which
            one. The only important thing is that the name of your app is displayed next to <guibutton>Current
            app:</guibutton> on the top right of the eXide window. If this is not the case, stop and
            check again! </para>
        </listitem>
        <listitem>
          <para> Click <guibutton>Application</guibutton> / <guibutton>Synchronize</guibutton> in
            the menu. It opens up a dialog with two fields: <guibutton>Start time</guibutton> and <guibutton>Target
            directory</guibutton> . When you synchronize the first time, empty the <guibutton>Start
            time</guibutton> field. Enter a valid, absolute directory path on your server machine
            into <guibutton>Target directory</guibutton> . </para>
        </listitem>
        <listitem>
          <para> Click the <guibutton>Synchronize</guibutton> button. This may take a moment, but
            you should see a list of written files at the bottom of the dialog afterwards. </para>
        </listitem>
        <listitem>
          <para>Change to the directory you specified for synchronize.</para>
        </listitem>
      </itemizedlist>

      <para>Watch the screencast below for the whole synchronization procedure.</para>
      <note>
        <title>Note</title>
        <para> for security reasons, the password you entered when creating the app is not stored in
          the database, so it cannot be synchronized to disk. To restore a password for your app,
          you thus need to edit the <filename>repo.xml</filename> file in the directory and add a <parameter>
          @password</parameter> attribute to the <tag>permissions</tag> element. </para>
      </note>
      <figure xml:id="sync">
        <title>Export an App</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Sync.gif" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section xml:id="appgen-build">
      <title>Building from a directory</title>
      <para> Once you have a copy of your app extracted in a local directory, you can always rebuild
        a fresh <filename>.xar</filename> from it. In the simplest case it is sufficient to call <command>
        ant</command> inside the directory. </para>
      <para> For up to date build instructions which also cover more advanced uses, refer to the
        "Building" section in the <link xlink:href="https://github.com/eeditiones/tei-publisher-app">readme
        of the TEI Publisher repository</link> . </para>
    </section>
  </section>
  <section xml:id="customization-best-practice">
    <title>Best Practice Recommendations</title>
    <para>In case you'd wish to further customize the generated app it's worth to keep the changes
      as much separated from the generated code as possible to allow for future alignment with newer
      versions of the TEI Publisher. </para>
    <para> The generated app shares most of its XQuery libraries with the main TEI Publisher app. A
      copy of those is included in the <filename>lib/</filename> collection of the generated app and <emphasis
        role="bold">should not</emphasis> be modified! This way you can later update the libraries
      to a newer TEI Publisher release without breaking your app. Including the libraries in the
      generated app creates some redundancy, but we chose to accept this trade-off to make it easier
      to view and modify everything relevant to the app. </para>
    <para> Meanwhile, if you find that modifications of <filename>lib/</filename> modules are
      necessary, please consider if your change would be generally beneficial for TEI Publisher and
      create PR for the TEI Publisher if so. </para>
    <para> It is <emphasis role="bold">considered safe</emphasis> : </para>
    <orderedlist>
      <listitem>
        <para> to modify all HTML templates below <filename>templates/</filename> as well as <filename>
          index.html</filename> and <filename>search.html</filename> in the root of the app </para>
      </listitem>
      <listitem>
        <para> to change XQuery modules in <filename>modules</filename> , excluding those in <filename>
          modules/lib</filename>
        </para>
      </listitem>
      <listitem>
        <para> to add images, fonts or change i18n translations below <filename>resources</filename>
        </para>
      </listitem>
      <listitem>
        <para> to add custom API functions (written in XQuery) to <filename>custom-api.json</filename>
          and <filename>custom-api.xql</filename>
        </para>
      </listitem>
    </orderedlist>
    <para> The following core XQuery modules in every app are safe to be modified (all are stored in <filename>
      modules</filename> subcollection: </para>
    <variablelist>
      <varlistentry>
        <term>
          <filename>config.xqm</filename>
        </term>
        <listitem>
          <para>The main configuration file for the app. It contains a number of parameters which
            control important aspects.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>custom-api.xql</filename>
        </term>
        <listitem>
          <para>Custom API functions should be defined in this module - or a module imported by it.
            Also, HTML templating modules should be imported into this module to be registered with
            the TEI Publisher.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>app.xql</filename>
        </term>
        <listitem>
          <para>Add your own HTML templating functions in XQuery here if needed. With TEI Publisher
            4.0 or later, there should be less of a need to extend this file as most of the
            application logic is realized via web components.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>pm-config.xql</filename>
        </term>
        <listitem>
          <para> This file is usually generated by calling <filename>modules/generate-pm-config.xql</filename>
            (see the <link linkend="multiple-odds">corresponding section</link> ). It defines the
            functions to be called for rendering TEI content via the processing model. It imports
            the modules generated from your ODD and assigns them to variables as function pointers.
            This approach is much more efficient than the dynamic lookups done by the main TEI
            Publisher app. It has been production tested on large web sites. </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>navigation-*.xql</filename>
        </term>
        <listitem>
          <para>This group of modules contains functions relevant for the display and navigation of
            documents corresponding to a given document type</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>query-*.xql</filename>
        </term>
        <listitem>
          <para>Modules with functions powering the search features</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>view.xql</filename>
        </term>
        <listitem>
          <para>The main module of the app. This module initializes eXist's templating system. The
            only case when it should be modified is if you want to add further XQuery library
            modules containing template functions.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="updating">
    <title>Updating Applications</title>
    <para>With TEI Publisher 8, we have factored out a number of functions away from the
        <code>modules/lib</code> to give users more control over their searches and presentation of
      the search results, which requires porting these functions into query modules of older apps.
      Recent breaking change to the <code>tei-publisher-lib</code>, a consequence of offering the
      Print CSS as a default print output also requires some manual updates.</para>
    <para>With TEI Publisher 7, we have redesigned the server-side API. Combined with the
      client-side reorganization brought by TEI Publisher 6, this will make future updates for
      generated applications a lot easier. Client-side UI and server-side API are now cleanly
      separated from any custom app elements.</para>
    <para>For apps created with TEI Publisher 6 updating to 7 requires only small modifications.
      Migrating from earlier versions, like 4 or 5, requires more effort, and is described in futher
      sections.</para>
    <section xml:id="upgrade7-8">
      <title>Upgrading from TEI Publisher 7 to 8</title>
      <para>With a major <code>tei-publisher-lib</code> version introducing some breaking changes it
        is necessary to adjust applications generated with older versions to accommodate the renamed
        output modes, follow <link linkend="upgrade-tp-lib-3">these steps</link>. Redesign of the
        search resulted in factoring out a number of functions from the <code>lib</code> module to
        customizable search modules, e.g. <code>modules/query-tei.xql</code>, therefore upgrade
        requires porting these changes to your application search modules.</para>
      <para>Upgrading an app generated by TEI Publisher 7 to involves the following general
        steps:</para>
      <procedure>
        <step>
          <para>Update the webcomponents library (also see the <link
              xlink:href="https://faq.teipublisher.com/webcomponents/version-upgrade/">faq</link>).
            The version used is defined by a single variable in
              <filename>modules/config.xqm</filename> :</para>
          <synopsis language="xquery">declare variable $config:webcomponents := "1.44.0";</synopsis>
        </step>
        <step>
          <para>Update server-side modules: those live in <filename>modules/lib</filename>. You can
            safely remove the entire folder and replace it with the corresponding one from the new
            version.</para>
        </step>
        <step>
          <para>Run a diff between your query modules and <code>modules/query-*.xql</code> and port
            all the new functions.</para>
        </step>
      </procedure>
    </section>
    <section xml:id="upgrade-tp-lib-3">
      <title>Upgrading to tei-publisher-lib 3.0.0</title>
      <para>Upgrading an app generated by TEI Publisher 7 to work with
          <code>tei-publisher-lib</code> 3.x.x or earlier involves the following steps before
        rebuilding and redeploying the app:</para>
      <procedure>
        <step>
          <para>Update <code>resources/odd/configuration.xml</code></para>
          <para>If you registered any custom XQuery module in your
              <code>resources/odd/configuration.xml</code> for the web output mode, make sure to
            also enable this for the print output mode by copying the corresponding configuration
            section as below </para>
          <para> If you never touched this file or don't know what it is for: skip this step. </para>

          <programlisting language="xml" xml:space="preserve">
            &lt;modules&gt;
              &lt;output mode="web"&gt;
                &lt;module uri="http://karlbarth.ch/apps/kb/ext-html.xql" prefix="ext-html"
                  at="xmldb:exist:///db/apps/kb/modules/ext-html.xql"/&gt;
              &lt;/output>
              &lt;!-- we need to add this because print extends web --&gt;
              &lt;output mode="print"&gt;
                &lt;module uri="http://karlbarth.ch/apps/kb/ext-html.xql" prefix="ext-html"
                  at="xmldb:exist:///db/apps/kb/modules/ext-html.xql"/&gt;
              &lt;/output&gt;
            &lt;/modules&gt;
            </programlisting>
        </step>
        <step>
          <para>Change <code>modules/lib/api/odd.xql</code> and <code>post-install.xql</code></para>
          <para> Around line 68 of <code>modules/lib/api/odd.xq</code>l (function
              <code>oapi:recompile</code>) you'll find a list of output modes. Various functions
            rely on this list when recompiling ODDs. Add the mode fo to the list: </para>
          <programlisting language="xquery" xml:space="preserve">for $module in
    if ($pi?output) then
        tokenize($pi?output)
    else
        ("web", "print", "latex", "epub", "fo")
...
            </programlisting>
          <para> You'll find a second list in function <code>local:generate-code</code> in the
            post-installation XQuery script <code>post-install.xql</code>. Add <code>fo</code> there
            as well. </para>
        </step>
      </procedure>
      <para>More elaborate explanation of the change and various scenarios is presented in this
          <link xlink:href="https://www.e-editiones.org/posts/tei-publisher-lib-3/" xlink:show="new"
          >e-editiones article</link>.</para>
    </section>
    <section xml:id="upgrade7">
      <title>Upgrading from TEI Publisher 7 to 7.x</title>
      <para>Upgrading an app generated by TEI Publisher 7 to another minor release involves the
        following general steps:</para>
      <procedure>
        <step>
          <para>Update the webcomponents library (also see the <link
              xlink:href="https://faq.teipublisher.com/webcomponents/version-upgrade/"
            >faq</link>).
            The version used is defined by a single variable in <filename>modules/config.xqm</filename>
            :</para>
          <synopsis language="xquery">declare variable $config:webcomponents := "1.24.12";</synopsis>
        </step>
        <step>
          <para>Update server-side modules: those live in <filename>modules/lib</filename>. You can
            safely remove the entire folder and replace it with the corresponding one from the new
            version.</para>
        </step>
      </procedure>
      <section xml:id="upgrade71">
        <title>Extra Steps for TEI Publisher 7.1</title>
        <para>The new annotation editor in TEI Publisher 7.1 requires a bunch of files to be copied.
          If you do not intend to support web annotations in your app (we recommend having a
          separate app for this), you only need step 1 and 2:</para>
        <procedure>
          <step>
            <para>Copy <filename>modules/annotation-config.xqm</filename> into the corresponding
              location in your app</para>
          </step>
          <step>
            <para>Copy <filename>templates/basic/controller.xql</filename> into the root of your
              app. This contains an important security fix. If you modified your controller
              yourself, just replace the last "else", which in the new version should start with:<programlisting
                language="xquery">let $main :=
        if (matches($exist:path, "^/+api/+(?:odd|lint)")) then 
            "api-odd.xql" 
        else if (matches($exist:path, "/+tex$") or matches($exist:path, "/+api/+apps/+generate$")) then
            "api-dba.xql"
        else 
            "api.xql"</programlisting></para>
          </step>
          <step>
            <para>Copy <filename>odd/annotations.odd</filename> to <filename>resources/odd</filename>
              in the generated app.</para>
          </step>
          <step>
            <para>Copy <filename>templates/pages/annotate.html</filename> and <filename>
              templates/pages/annotate.css</filename> to the corresponding folders.</para>
          </step>
          <step>
            <para>Also copy <filename>resources/scripts/annotations</filename></para>
          </step>
        </procedure>
      </section>
    </section>
    <section xml:id="update6-7">
      <title>Upgrading from TEI Publisher 6 to 7</title>
      <para> To upgrade a custom application generated with TEI Publisher 6 to version 7, we
        recommend to clone the source code of both, TEI Publisher 7 and the custom application, into
        a local directory. The commands shown below were used on a Linux system for <link
          xlink:href="https://github.com/eeditiones/dodis-wall/commit/491267575a97c101361e10de4001db2f97cc3d29">updating
        the Dodis demo app</link> , but with appropriate adjustments to the syntax the same actions
        could be performed on a different operating system. Alternatively the migration can be
        executed using eXide's file manager. </para>
      <para>If you decide to work with the command line, as suggested here, clone TEI Publisher 7
        into the directory one level above the one containing your own application source code:</para>
      <programlisting language="shell" xml:space="preserve">git clone https://github.com/eeditiones/tei-publisher-app.git
cd tei-publisher-app
git checkout v7.0.0</programlisting>
      <para>At this point we need to move to the directory where your own application source code is
        stored:</para>
      <programlisting language="shell" xml:space="preserve">cd ../my-custom-app</programlisting>
      <section xml:id="updating-copy">
        <title>Copy files</title>
        <para> Now we need to remove the old <filename>modules/lib</filename> directory and replace
          it entirely with the new one from the TEI Publisher 7. We'll also copy a bunch of files
          from the <filename>templates</filename> subdirectory of TEI Publisher: </para>
        <programlisting language="shell" xml:space="preserve">
rm -rf modules/lib
cp -r ../tei-publisher-app/modules/lib/ modules/
cp ../tei-publisher-app/templates/basic/pre-install.xql .
cp ../tei-publisher-app/templates/basic/post-install.xql .
cp ../tei-publisher-app/templates/basic/controller.xql .
cp ../tei-publisher-app/resources/css/theme.css resources/css
cp ../tei-publisher-app/templates/basic/modules/custom-api.* modules/
cp ../tei-publisher-app/templates/basic/modules/facets.xql modules/
cp ../tei-publisher-app/templates/api.html templates/</programlisting>
        <para> Ideally, these files should not have been modified by you, if you followed our
          earlier <link linkend="customization-best-practice">best practice recommendations</link> .
          Otherwise you may need to reapply your changes. </para>
        <para> Next, copy the <filename>navigation*</filename> and <filename>query*</filename>
          modules. These are intended to be customized, so you may have changed them in your custom
          app. Compare the versions and make sure you reapply your modifications, if any. </para>
        <programlisting language="shell" xml:space="preserve">cp ../tei-publisher-app/modules/navigation* modules/
cp ../tei-publisher-app/modules/query*.xql modules/</programlisting>
        <note>
          <para> Note that the naming of the <filename>query-*.xql</filename> has changed to be
            constistent with the <filename>navigation-*.xql</filename> files. </para>
        </note>
        <para>Same considerations apply to the HTML templates for menus and the toolbar.
          Nevertheless, changes in these areas were quite minor, so you may alternatively postpone
          this step untill you encounter concrete issues in your application:</para>
        <programlisting language="shell" xml:space="preserve">cp ../tei-publisher-app/templates/menu.* templates/
cp ../tei-publisher-app/templates/toolbar.html templates/
cp ../tei-publisher-app/templates/drawer.html templates/</programlisting>
      </section>
      <section xml:id="updating-templates">
        <title>Edit HTML templates</title>
        <note>
          <title>Important</title>
          <para> TEI Publisher 7 expects all HTML files to reside in the <filename>templates</filename>
            subfolder. Previous versions used a mix of locations with some HTML files in the root of
            the app. You should thus copy your <filename>index.html</filename> , <filename>
            search.html</filename> , <filename>error-page.html</filename> and any other custom HTML
            files into <filename>templates</filename> first. </para>
        </note>
        <para> Also, because TEI Publisher 7 has a well-defined API to handle the communication
          between user interface components and server-side functionality, we need to change some of
          the URLs in the HTML templates we're using. As a rule of thumb, all URLs previously
          calling XQuery modules directly, should now start with <code>api/</code> followed by the
          correct API path. The main HTML template to be changed is <filename>index.html</filename>
          . Please search and replace the properties for the following webcomponents: </para>
        <synopsis language="xml">&lt;pb-download url="modules/lib/app-download.xql"&gt;</synopsis>
        <para>should be changed into</para>
        <synopsis language="xml">&lt;pb-download url="api/apps/download"&gt;</synopsis>
        <para>and</para>
        <synopsis language="xml">&lt;pb-custom-form id="facets" url="modules/facets.xql" event="pb-results-received" subscribe="docs" emit="docs"/&gt;
&lt;pb-browse-docs id="document-list" url="collection/" ...&gt;</synopsis>
        <para>should be changed into</para>
        <synopsis language="xml">&lt;pb-custom-form id="facets" url="api/search/facets" event="pb-results-received" subscribe="docs" emit="docs"&gt;&lt;/pb-custom-form&gt;
&lt;pb-browse-docs id="document-list" url="api/collection/" ...&gt;</synopsis>
        <para> The last change should also be applied to <filename>search.html</filename> and you
          should change the <tag>pb-load</tag> loading the search results to read: </para>
        <synopsis language="xml">&lt;pb-load id="results" url="api/search" emit="results"&gt;&lt;/pb-load&gt;</synopsis>
        <para> Also check <filename>templates/pages/view.html</filename> and any other page template
          your app uses. Search for calls to <filename>.xql</filename> or <filename>modules/</filename>
          and replace them with appropriate API paths. If you were making direct calls to custom
          modules, e.g. from <code>pb-load</code> component, these need to be added as <link
            linkend="customizations6-7">custom API endpoints</link> . </para>
      </section>
      <section xml:id="updating-config">
        <title>Update config.xqm</title>
        <para> Finally, a few settings need to be added to the main configuration module, <filename>
          modules/config.xqm</filename> : </para>
        <orderedlist>
          <listitem>
            <para> Change <parameter>$config:webcomponents</parameter> to at least version <code>
              1.13.0</code> . </para>
          </listitem>
          <listitem>
            <para> Check for missing variables or functions and copy these from <filename>
              tei-publisher-app/templates/basic/modules/config.xqm</filename> , in particular: </para>
            <itemizedlist>
              <listitem>
                <para>$config:odd-available</para>
              </listitem>
              <listitem>
                <para>$config:odd-internal</para>
              </listitem>
              <listitem>
                <para>config:collection-config()</para>
              </listitem>
              <listitem>
                <para>config:default-config()</para>
              </listitem>
              <listitem>
                <para>config:document-type()</para>
              </listitem>
              <listitem>
                <para>config:get-document()</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </orderedlist>
      </section>

      <section xml:id="customizations6-7">
        <title>Check for other customizations</title>
        <para>In most cases you will now be able to rebuild your custom app, redeploy it to eXist
          and test. If you encounter any error messages, they are most likely due to additional
          modifications you applied to your custom app. These are usually located in two main areas:</para>
        <variablelist>
          <varlistentry>
            <term>Custom HTML templating functions</term>
            <listitem>
              <para> Earlier versions of TEI Publisher relied heavily on eXist's HTML templating
                framework and custom apps would add their own templating functions into <filename>
                modules/app.xql</filename> (or additional modules). This approach is still perfectly
                valid. </para>
              <para> Everything will work as expected if you've just extended <filename>
                modules/app.xql</filename> . However, if you have added other modules containing
                templating functions, now you need to import these explicitly into <filename>
                modules/custom-api.xql</filename> . </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Custom XQuery main modules</term>
            <listitem>
              <para> If your custom app makes direct calls to XQuery main modules (e.g. via the <code>
                pb-load</code> component), these have to be rewritten. TEI Publisher 7 expects all
                API calls to go through the Open API router - direct calls to XQuery modules are no
                longer supported. Therefore you need to transform your code into functions which can
                be called via the Open API, e.g. by adding them to <filename>modules/custom-api.xql</filename>
                or importing them there. </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section xml:id="customizations6-7-cleanup">
        <title>Remove superfluous code</title>
        <para>Now you can remove files which are no longer used:</para>
        <programlisting language="shell" xml:space="preserve">
rm templates/toc.html
rm templates/search-results.html
rm modules/view.xql</programlisting>
      </section>
      <section xml:id="customizations6-7-endpoints">
        <title>Change API endpoints</title>
        <para> Finally, to be able to view and test the API of your custom app, you should change
          the endpoints in the Open API specification files. In both, <code>modules/lib/api.json</code>
          and <code>modules/custom-api.json</code> , change the url property in the following
          section: </para>
        <programlisting language="javascript" xml:space="preserve">
"servers": [
    {
        "description": "Endpoint for testing on localhost",
        "url": "http://localhost:8080/exist/apps/tei-publisher"
    }
],</programlisting>
        <para>Change the final part of the URL to match the name of your app instead of
          "tei-publisher". If you are on a remote server, adjust the whole url accordingly.</para>
      </section>
    </section>
    <section xml:id="update5-7">
      <title>Migrating from TEI Publisher 4, 5 or earlier</title>
      <para>If you are migrating to version 7 from TEI Publisher 5, 4 or earlier, you also need to
        pay attention to the user interface redesign introduced by TEI Publisher 6. This makes
        things more difficult and there are two possible approaches for updating:</para>
      <itemizedlist>
        <listitem>
          <para> generate a new application with TEI Publisher 7 and merge your changes in into the
            newly generated app. This is the recommended method. If your customizations were limited
            to e.g. ODD files, CSS styles, templates, index configurations or adding your own code
            in <filename>modules/</filename> , it should all go very smoothly. </para>
        </listitem>
        <listitem>
          <para>update your generated app by modifying the HTML templates you use and copying files
            from TEI Publisher.</para>
        </listitem>
      </itemizedlist>
      <para>The first option is strongly recommended and much easier in general. The second option
        is only for experienced users who have to update apps containing a lot of customized code.</para>
      <section xml:id="update5-7-newapp">
        <title>Update by Generating a New Application</title>
        <procedure>
          <step>
            <para>Upload your customized ODD to the TEI Publisher 7</para>
          </step>
          <step>
            <para> If you created a custom HTML template for your document view, upload it to the <filename>
              templates/pages</filename> collection of the TEI Publisher. You can use eXide's file
              manager to do so. </para>
          </step>
          <step>
            <para>Generate a new application using your custom ODD. Make sure to choose a different
              URL and short name to not confuse the old and new app.</para>
          </step>
          <step>
            <para> Adjust <filename>modules/config.xqm</filename> variables, if necessary. </para>
          </step>
          <step>
            <para> Selectively upload all other files you changed or resources you added to the
              generated app (data, CSS). In case of custom page templates and XQuery modules follow
              recommendations for <link linkend="update6-7">updating from Publisher 6</link> . </para>
          </step>
        </procedure>
      </section>
      <section xml:id="update5-7-copy">
        <title>Update by copying</title>
        <note>
          <para> This approach is for experienced users only and not recommended. We mainly keep it
            here for reference. This guide has been created for updating to TEI Publisher 6, so you
            will also need to follow the instructions for <link linkend="update6-7">migrating from 6
            to 7</link> and apply the steps not described below. </para>
        </note>
        <para>The following steps assume that you either</para>
        <itemizedlist>
          <listitem>
            <para>have a copy of your app's code on the filesystem and either a clone of TEI
              Publisher 6 or an app skeleton generated by TEI Publisher 6 (preferred) next to it</para>
          </listitem>
          <listitem>
            <para>or have your app and TEI Publisher installed in your database. In this case use
              eXide's file manager to copy files</para>
          </listitem>
        </itemizedlist>
        <para> In the following, the TEI Publisher 6 app you are copying from will be identified as <parameter>
          $source</parameter> . </para>
        <procedure>
          <step>
            <para> Edit <filename>modules/config.xqm</filename> and add two variables at the top: <code>
              $config:origin-whitelist</code> and <code>$config:webcomponents</code> . </para>
            <para>
              <parameter>$config:webcomponents</parameter> should point to the latest version of
              pb-components. </para>
            <programlisting language="xquery" xml:space="preserve">
(:~
 : A list of regular expressions to check which external hosts are
 : allowed to access this TEI Publisher instance. The check is done
 : against the Origin header sent by the browser.
 :)
declare variable $config:origin-whitelist := (
"(?:https?://localhost:.*|https?://127.0.0.1:.*)"
);

(:~~
 : The version of the pb-components webcomponents library to be used by this app.
 : Should either point to a version published on npm,
 : or be set to 'local'. In the latter case, webcomponents
 : are assumed to be self-hosted in the app (which means you
 : have to npm install it yourself using the existing package.json).
 : If a version is given, the components will be loaded from a public CDN.
 : This is recommended unless you develop your own components.
 :)
declare variable $config:webcomponents := "0.9.11";</programlisting>
            <para> Other variables in <filename>conf.xml</filename> which may need to be updated
              are: </para>
            <itemizedlist>
              <listitem>
                <para>$config:data-default</para>
              </listitem>
              <listitem>
                <para>$config:data-exclude</para>
              </listitem>
              <listitem>
                <para>$config:context-path</para>
              </listitem>
            </itemizedlist>
          </step>
          <step>
            <para> Copy all XQuery files from <filename>$source/modules/lib</filename> into the <filename>
              modules/lib</filename> of your application. </para>
          </step>
          <step>
            <para> Copy <filename>$source/resources/css/theme.css</filename> into the same location
              in your application. </para>
          </step>
          <step>
            <para> In all HTML files <emphasis>you changed for your app</emphasis> , check <tag>head</tag>
              and remove any <tag>script</tag> element or <tag>link</tag> doing an import like: </para>
            <programlisting language="html">&lt;link rel="import" href="components/dependencies-dev.html"/&gt;</programlisting>
            <para>Instead add the following line to the head:</para>
            <programlisting language="html">&lt;script type="module" src="pb-components-bundle.js" data-template="pages:load-components"&gt;&lt;/script&gt;</programlisting>
            <para> Also add a link to <filename>theme.css</filename> : </para>
            <programlisting language="html">&lt;link rel="stylesheet" href="resources/css/theme.css"/&gt;</programlisting>
          </step>
          <step>
            <para> Copy <filename>$source/resources/css/theme.css</filename>
            </para>
          </step>
          <step>
            <para> Copy <filename>$source/resources/i18n</filename> . The existing <filename>*.xml</filename>
              in your directory can be deleted - unless you added your own translated keys, in which
              case you would need to move them into the corresponding json format. </para>
          </step>
          <step>
            <para> HTML files you did not change may just be overwritten by copying the
              corresponding versions from <code>$source</code> . In particular this includes files
              in the <filename>$source/templates/basic/templates</filename> subdirectory. </para>
          </step>
          <step>
            <para> Copy <filename>$source/templates/basic/controller.xql</filename> into the root of
              your application - unless you made changes to this file yourself, in which case you
              would need to merge it. </para>
          </step>
          <step>
            <para> Check the files in modules within your app: if you have not changed any of them,
              just copy the corresponding files from <filename>tei-publisher-app/modules</filename>
              . See if you need to merge the modified ones. </para>
          </step>
          <step>
            <para> i18n translations are now applied client-side rather than server-side. This means
              you should drop all references to <code>data-template="i18n:translate"</code> and the
              i18n namespace from your HTML. Also remove the i18n module import from your <filename>
              modules/view.xql</filename> or overwrite the file if you have not modified it. </para>
          </step>
        </procedure>
        <para> You may consult the diff of an actual update from Publisher 5 to 6 in the dodis-wall
          repository on github: <link
            xlink:href="https://github.com/eeditiones/dodis-wall/commit/9c3757d909932db458d2a777b7a952a8ee4dcc9e"
            xlink:show="new">update to publisher 6: update templates, configuration and styling</link>
        </para>
      </section>
    </section>
  </section>
  <section xml:id="data-organization">
    <title>Data</title>
    <para>TEI Publisher ships its data files within the same application package. Nevertheless,
      separating your data from application code has many benefits, particularly for actively
      developed applications and data sets. This way changes to your code can be deployed without
      redeploying and reindexing your data and vice versa. It is also easier to maintain separate
      repositories (e.g. in Git) and differentiate privileges for editorial and developer teams.</para>
    <para> While we would generally recommend separating data and code, some projects may still
      prefer to keep their data and application integrated in a single <emphasis>xar</emphasis>
      package for the sake of marginally easier distribution. </para>
    <para>Internal structure of the data collection can be arbitrary, though there are some
      considerations regarding index configuration to take into account.</para>
    <section xml:id="data-collection">
      <title>Data collection</title>
      <para> Two variables in <filename>config.xqm</filename> are used to configure location of the
        data collection. <code>$config:data-root</code> specifies where in the collection hierarchy
        the data is stored. Only the top level collection needs to be specified. </para>
      <programlisting language="xquery" xml:space="preserve">
(:~
 : The root of the collection hierarchy containing data.
 :)
declare variable $config:data-root := $config:app-root || "/data";
    </programlisting>
      <para> Switching to a separate data package is as simple as changing this variable, e.g.
        assuming that we store our data in <code>/db/apps/lgpn-ling-data/data</code> , the <code>
        data-root</code> should be defined as: </para>
      <programlisting language="xquery" xml:space="preserve">
      declare variable $config:data-root := '/db/apps/lgpn-ling-data/data';
    </programlisting>
      <para> In the variable <parameter>$config:data-exclude</parameter> you may specifiy a sequence
        of root elements which should be excluded from the list of document shown in the browsing
        view, e.g. secondary data files like a taxonomy or entity lists. </para>
      <para> You may find it helpful to create and build the data package starting from the template
        hosted in the <link xlink:href="https://github.com/eeditiones/tei-publisher-data-template"
          xlink:show="new">e-editiones repository</link> . README document provided there explains
        shortly roles of all the files and how to adjust them to your needs. </para>

      <note>
        <para> It is critical to store index configuration file, <filename>collection.xconf</filename>
          in the correct location. Refer to <link
            xlink:href="https://exist-db.org/exist/apps/doc/indexing.xml" xlink:show="new">eXist-db
          documentation</link> for details but it is common practice to store a collection
          configuration in the data package and rely on mechanisms of pre-install script ( <filename>
          pre-install.xql</filename> ) to copy the file to its required position in <filename>
          /db/system/config</filename> . </para>
        <para> Similar consideration applies if fulltext index makes use of any external function
          module, which in TEI Publisher and generated apps is commonly the case for facet and field
          definitions. This module needs to be stored before the index is to be applied and usually
          it's best to store it in the same location as <filename>collection.xconf</filename> . </para>
      </note>
    </section>
    <section xml:id="subcollections">
      <title>Subcollections</title>
      <para> Many editions will simply present a number of documents, e.g. a collection of letters
        like <link xlink:href="https://teipublisher.com/exist/apps/vangogh/index.html"
          xlink:show="new">Van Gogh</link> or plays like <link
          xlink:href="https://teipublisher.com/exist/apps/shakespeare-pm/index.html">Shakespeare</link>
        demo. Structure of the data is therefore very simple, all the files are stored on the same
        level in the <code>data-root</code> collection. </para>

      <para> Other publications, particularly those including heterogeneous material may require a
        more complex organization. TEI Publisher itself is a good example - its <code>data</code>
        collection is further divided into three subcollections: <filename>doc</filename> (for
        documentation), <filename>test</filename> (for examples) and <filename>playground</filename>
        (for user-supplied material). </para>
      <figure>
        <title>Structure of TEI Publisher's data collection</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="data-collection.png" width="312px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> You will note that it also contains other resources: image files and even an HTML file.
        Specify the <code>$config:data-default</code> variable in <filename>modules/config.xqm</filename>
        to set which collection should be used as a point of entry to your data. Whenever <filename>
        collection.html</filename> is present in that location, it will be used as a custom landing
        page displayed instead of a simple document listing. In case of the TEI Publisher it would
        be the Demo Collection, Playground and Documentation </para>

      <programlisting language="xquery" xml:space="preserve">
(:~
 : The root of the collection hierarchy whose files should be displayed
 : on the entry page. Can be different from $config:data-root.
 :)
declare variable $config:data-default := $config:data-root;
    </programlisting>
      <para> This approach can be extended further, say if you wanted to add a <filename>prints</filename>
        and <filename>manuscripts</filename> subcollection to the <filename>playground</filename>
        and present them in a custom landing page. Just add the data and a corresponding <filename>
        collection.html</filename> into the <filename>playground</filename> . You can shape the
        custom landing page however you like, using the full power of HTML and eXist templating. </para>
      <figure>
        <title>Subcollections</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="data-subcollections.png" width="312px" />
          </imageobject>
        </mediaobject>
      </figure>
      <figure>
        <title>Fragment of the subcollections landing page</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="data-subcollection-landing.png" width="512px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> The landing page like this could be created with this HTML template stored in <filename>
        data/playground/collection.html</filename> . </para>
      <programlisting language="html" xml:space="preserve">
&lt;div class="collection" data-template="browse:clear-facets"&gt;
    &lt;h3&gt;Custom landing page demonstrating sub-subcollections.&lt;/h3&gt;
    &lt;ul class="documents"&gt;
        &lt;li class="document"&gt;
            &lt;div class="thumbnail"&gt;&lt;img src="demo.png" width="128"/&gt;&lt;/div&gt;
            &lt;div class="document-info"&gt;
                &lt;h3&gt;&lt;a href="#" data-collection="playground/prints"&gt;Prints&lt;/a&gt;&lt;/h3&gt;
                &lt;p&gt;This one is for prints.&lt;/p&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        &lt;li class="document"&gt;
            &lt;div class="thumbnail"&gt;&lt;img src="demo.png" width="128"/&gt;&lt;/div&gt;
            &lt;div class="document-info"&gt;
                &lt;h3&gt;&lt;a href="#" data-collection="playground/manuscripts"&gt;Manuscripts&lt;/a&gt;&lt;/h3&gt;
                &lt;p&gt;This one is for manuscripts.&lt;/p&gt;
            &lt;/div&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
      </programlisting>
    </section>

    <section xml:id="pi-config">
      <title>Processing instructions</title>
      <para> The default view for a specific document can be configured via a processing
        instruction. Before displaying a document, TEI publisher will check if a processing
        instruction exists at the start of the document, telling it which ODD and view template to
        use (along with other configuration parameters). For example, the following processing
        instruction associates the document with the view template <filename>translation.html</filename>
        , the ODD <filename>dantiscus.odd</filename> , and switches to a page-by-page display (along
        TEI page break boundaries): </para>
      <programlisting language="xml" xml:space="preserve">&lt;?teipublisher template="translation.html" odd="dantiscus.odd" view="page"?&gt;</programlisting>
      <para>When viewing the document by structural divisions, two additional settings control the
        amount of content displayed at a time:</para>
      <programlisting language="xml" xml:space="preserve">&lt;?teipublisher depth="2" fill="6" odd="dta.odd"?&gt;</programlisting>
      <variablelist>
        <varlistentry>
          <term>odd</term>
          <listitem>
            <para>The ODD file to use for rendering the document.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>template</term>
          <listitem>
            <para> The HTML view template to use. Default is <code>view.html</code> as configured in <filename>
              modules/config.xqm</filename> . </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>view</term>
          <listitem>
            <para> Default view to show when browsing the document. Supported values are <parameter>
              div</parameter> , <parameter>page</parameter> or <parameter>single</parameter> : </para>
            <orderedlist>
              <listitem>
                <para>
                  <parameter>div</parameter> : displays one structural division (TEI div, docbook
                  section …) at a time </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>page</parameter> : displays the document page by page. This requires
                  page break indicators to be present ( <tag>pb</tag> in TEI, not supported for
                  docbook). </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>single</parameter> : the entire document (or a selected fragment of it)
                  is displayed at once </para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>depth</term>
          <listitem>
            <para> When viewing entire divisions, the software tries to determine if it should show
              child divisions in separate pages or include them with the current div. <tag>depth</tag>
              indicates the nesting level up to which divisions should be shown separately. So
              setting it to "2" will result in divisions on level 3 or greater to be shown together
              with their enclosing div. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>fill</term>
          <listitem>
            <para> If child divisions appear on separate pages, it may happen that the enclosing div
              contains just a heading or a single line of text. In this case, the algorithm will try
              to fill the page by showing the first child division as well. The <tag>fill</tag>
              paramter defines the number of elements which should at least be present on a page. If
              not, the software tries to fill it up. </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section xml:id="facets">
    <title>Facet Search Configuration</title>
    <para>Facets allow users to quickly navigate through a set of documents or query results by
      selecting from predefined categories or properties. This way, users can "drill down" into the
      set, reducing the number of displayed items with every step. For demonstration purposes, TEI
      Publisher configures two facets by default: "Genre" and "Language". You can see those to the
      left of the document list on the start page, or below the search box on the search result
      page.</para>
    <figure>
      <title>Facets on the start page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="facets.png" />
        </imageobject>
      </mediaobject>
    </figure>
    <para> From a user perspective, the main concept behind facets is the <emphasis>drill down</emphasis>
      : initially the user sees all facet values associated with the set of documents or search
      results displayed. The number behind each value denotes the number of items in the set having
      the particular facet set. As the user selects one facet, the set necessarily becomes smaller,
      so non-matching facet values will disappear and the numbers adjust accordingly. </para>
    <para> Facets are a new feature in eXist 5.0. They are super fast because eXist will create them
      when indexing the document. No extra computation is needed when the user clicks on a facet to
      drill down into a displayed set: all information is already available in the index. To see a
      more complex example of facets in action, visit our <link xlink:show="new"
        xlink:href="https://teipublisher.com/exist/apps/vangogh/index.html">Van Gogh</link> demo. </para>
    <para>If you would like to configure other or additional facets, you need to edit three files:</para>
    <variablelist>
      <varlistentry>
        <term>
          <filename>collection.xconf</filename>
        </term>
        <listitem>
          <para> The <filename>collection.xconf</filename> tells eXist how to index the collection.
            The default configuration in TEI Publisher creates two Lucene full-text indexes for TEI
            on <tag>tei:text</tag> and <tag>tei:div</tag> . Each of those may have facets attached.
            Every facet must have a <parameter>dimension</parameter> and an <parameter>expression</parameter>
            attribute. The expression is an arbitrary XPath/XQuery string. For every element being
            indexed, the expression is evaluated once and the result defines the string values which
            will be associated with the specified facet dimension. </para>
          <para> For a description of how full-text indexes and facets are defined in the <filename>
            collection.xconf</filename> , please refer to the <link xlink:show="new"
              xlink:href="http://exist-db.org/exist/apps/doc/lucene">eXist documentation</link> . </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>index.xql</filename>
        </term>
        <listitem>
          <para> If you open the default <filename>collection.xconf</filename> , you'll see that
            most facet expressions call a function <function>nav:get-metadata</function> . This
            function is declared in <filename>index.xql</filename> . By externalizing most of the
            code into a separate function, we can keep the index configuration clean and short. </para>
          <para> The default <filename>index.xql</filename> already does some advanced
            preprocessing, in particular for the "genre" facet: each of the sample documents
            references a central taxonomy (contained in <filename>data/taxonomy.xml</filename> ).
            The references are resolved at indexing time by following the <tag>catRef</tag>
            element's <parameter>@target</parameter> attribute. Note that we create a hierarchical
            facet, because e.g. "Philosophy" is a sub-category of "Prose". The code in function <function>
            idx:get-genre</function> will automatically include the super-category. </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <filename>config.xqm</filename>
        </term>
        <listitem>
          <para> While the other two files cover the server-side creation of facets, we also need a
            place where we define how facets should be displayed in the user interface. The main
            configuration module: <filename>config.xqm</filename> declares a variable <parameter>
            $config:facets</parameter> . It should contain an array of maps, where each map defines
            the settings for one dimension, e.g.: </para>
          <programlisting language="xquery" xml:space="preserve">
(:
 : Display configuration for facets to be shown in the sidebar. The facets themselves
 : are configured in the index configuration, collection.xconf.
 :)
declare variable $config:facets := [
    map {
        "dimension": "genre",
        "heading": "Genre",
        "max": 5,
        "hierarchical": true()
    },
    map {
        "dimension": "language",
        "heading": "Language",
        "max": 5,
        "hierarchical": false(),
        "output": function($label) {
            switch($label)
                case "de" return "German"
                case "es" return "Spanish"
                case "la" return "Latin"
                case "fr" return "French"
                case "en" return "English"
                default return $label
        }
    }
];
</programlisting>
          <para>The map properties are as follows:</para>
          <variablelist>
            <varlistentry>
              <term>dimension</term>
              <listitem>
                <para> The name of the dimension. Should correspond to the value of the <parameter>
                  @dimension</parameter> attribute used in <filename>collection.xconf</filename>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>heading</term>
              <listitem>
                <para>The heading to display above the facet values</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>max</term>
              <listitem>
                <para> Maximum number of facet values to be displayed initially. More can be shown
                  if the user clicks on the <guilabel>Show All</guilabel> checkbox. Pass an empty
                  sequence, i.e. (), to not limit the number and hide the checkbox. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>hierarchical</term>
              <listitem>
                <para> Defines if the facet is hierarchical, which means that only the top-level
                  facet values in the hierarchy will be shown initially. If the user selects one
                  top-level value, the interface will expand and show the sub-categories. For this
                  to work the facet must be configured as "hierarchical" in <filename>
                  collection.xconf</filename>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>output</term>
              <listitem>
                <para>A function which can be used to process the facet value before display. The
                  facet label will be replaced by whatever the function returns.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="embedding">
    <title>Embedding TEI Publisher in other systems</title>
    <para> Since version 6.0, all <code>pb-components</code> can be used <emphasis>outside</emphasis>
      TEI Publisher itself. The components can be embedded into any environment, e.g. a CMS or blog
      software (like WordPress or Drupal) or integrated into any modern front-end framework (like
      vue, react or angular). All that is needed is a TEI Publisher instance available on the web
      which stores the source TEI and provides a communication endpoint for the components to talk
      to. </para>

    <section xml:id="embedding-examples">
      <title>Live Examples</title>
      <para> The embedded example below demonstrates such a use case: it provides a sandbox running
        on <link xlink:show="new" xlink:href="https://codepen.io">codepen.io</link> but communicates
        with the TEI Publisher instance on <link xlink:show="new"
          xlink:href="https://teipublisher.com">teipublisher.com</link> which stores the documents.
        The magic happens in the <code>endpoint</code> attribute passed to <tag>pb-page</tag> ,
        which tells the components where to talk to: </para>
      <programlisting role="codepen" xlink:href="wolfgangmm#YzXEvvw" />
      <para> You can actually edit the code above: for example, try to change the path for the first
        document to <filename>test/F-rom.xml</filename> and the odd to <code>shakespeare</code> .
        See how the live view changes? </para>
      <para> And if you would like to read <emphasis>Romeo and Juliet</emphasis> in two-column mode,
        just add <code>column-separator=".tei-cb"</code> to the main <tag>pb-view</tag> . </para>
    </section>

    <section xml:id="embedding-whole-doc">
      <title>Retrieving the whole document as a simple HTML</title>
      <!-- REVIEW: shall we leave the description how to write your own XQuery or should we
      recommend only using new API for transformations? -->
      <para>Embedding results of applying Processing Model transformation on a document is even
        simpler. Behind the scenes, TEI Publisher has a separate library part, which is essentially
        an implementation of the TEI processing model. This library can be used independently to
        retrieve the entire content of a TEI document as HTML, transformed through an ODD with
        processing instructions.</para>
      <para>All you need is a small XQuery which calls the library modules, setting the correct
        source document and ODD. Fortunately, TEI Publisher already contains a boilerplate XQuery
        script for this job, which you can call as follows in your browser:</para>
      <para>
        <link xlink:show="new"
          xlink:href="https://teipublisher.com/exist/apps/tei-publisher/api/document/test%2FF-rom.xml/html?odd=shakespeare.odd">
        https://teipublisher.com/exist/apps/tei-publisher/api/document/test%2FF-rom.xml/html?odd=shakespeare.odd</link>
      </para>
      <para> This will retrieve the content of Shakespeare's <emphasis>Romeo and Juliet</emphasis>
        as an HTML page, transformed through the odd <filename>shakespeare.odd</filename> . For
        embedding an entire document in an iframe or similar, this should already be enough. Please
        note that <emphasis role="bold">/</emphasis> character in the path to the document <parameter>
        test/F-rom.xml</parameter> had to be URL encoded as <parameter>%2F</parameter> . </para>
    </section>
    <section xml:id="embedding-webcomponents">
      <title>Embedding webcomponents for navigation</title>
      <para>For longer documents, embedding the entire content in a page may not be too
        user-friendly. A better way is to use the library of webcomponents provided by TEI
        Publisher. This way, we can show the content page by page or division by division, allowing
        the reader to navigate between sections.</para>
      <programlisting role="codepen" xlink:href="wolfgangmm#ExVQKBK" />
      <para>Because webcomponents are part of the HTML5 standard and supported natively by most
        modern browsers, we can easily import the component library which is at the core of the TEI
        Publisher app and reuse the components it provides in other contexts. They should work in
        any HTML5 page, no matter if it was written by hand, is generated by PHP, Python or a CMS.</para>
      <para>For a start, the page should import two scripts in its header:</para>
      <programlisting language="html" xml:space="preserve">&lt;script src="https://cdn.jsdelivr.net/npm/web-components-loader/lib/index.min.js"&gt;&lt;/script&gt;
&lt;script type="module" src="https://cdn.jsdelivr.net/npm/@teipublisher/pb-components/dist/pb-components-bundle.min.js"&gt;&lt;/script&gt;</programlisting>
      <para> This imports necessary <code>pb-components</code> libraries from <code>jsdelivr.net</code>
        CDN which is considered the best practice for web sites. </para>
      <para> The second <tag>script</tag> tag imports all the components provided by TEI Publisher.
        Note that here <code>pb-components@latest</code> points to the latest available bundle, but
        you could specify a concrete version number to make sure your website uses a fixed release. </para>

      <para> Now let's actually use the components to display Shakespeare's <emphasis>Romeo and
        Juliet</emphasis> : in the HTML <tag>body</tag> , include the following snippet: </para>
      <programlisting language="html" xml:space="preserve">&lt;pb-page endpoint="https://teipublisher.com/exist/apps/tei-publisher"&gt;
    &lt;pb-document id="document1" path="test/F-rom.xml" odd="shakespeare"&gt;&lt;/pb-document&gt;
    &lt;!-- Navigate to previous page --&gt;
    &lt;pb-navigation direction="backward" unit="page" keyboard="left"&gt;
      &lt;paper-button&gt;
         &lt;iron-icon icon="icons:chevron-left"&gt;&lt;/iron-icon&gt;
      &lt;/paper-button&gt;
    &lt;/pb-navigation&gt;
    &lt;pb-view id="view1" src="document1" view="page"&gt;&lt;/pb-view&gt;
    &lt;!-- Navigate to next page --&gt;
    &lt;pb-navigation direction="forward" unit="page" keyboard="right"&gt;
      &lt;paper-button&gt;
         &lt;iron-icon icon="icons:chevron-right"&gt;&lt;/iron-icon&gt;
      &lt;/paper-button&gt;
    &lt;/pb-navigation&gt;
&lt;/pb-page&gt;</programlisting>
      <para> In the <tag>pb-page</tag>
        <code>endpoint</code> attribute we need to provide a critical
        piece of information: the URL of the TEI Publisher instance for all the components to
        communicate with. If you have set up your own instance of eXist-db and TEI Publisher, you
        should change the URL <emphasis>to point to your instance</emphasis> . This is important
        because the components will expect the documents you want to display to be stored in the
        same instance. </para>
      <para>
        <tag>pb-document</tag> defines the document to be displayed. The path is relative to the
        data root of the TEI Publisher instance. It also specifies the ODD to be used for the
        transformation. </para>
      <para>
        <tag>pb-view</tag> is the main component for displaying the transformed content. It
        references the <tag>pb-document</tag> to use as source in its <option>src</option>
        attribute. The Shakespeare does tag page breaks, so we switch to page-by-page view via the <option>
        view</option> attribute to show the user only one page at a time. The default would be to
        use a division-by-division view ( <code>view="div"</code> ), but you could also request the
        entire content at once using <code>view="single"</code> . </para>
      <para>
        <tag>pb-navigation</tag> adds forward/backward navigation buttons to the page, allowing the
        user to switch to the next/previous page of the document. You can use various types of
        buttons, but in this case we're choosing a <tag>paper-button</tag> element with a chevron <tag>
        iron-icon</tag> (both <tag>paper-button</tag> and <tag>iron-icon</tag> are part of the
        standard <link xlink:show="new"
          xlink:href="https://www.webcomponents.org/author/PolymerElements">Polymer elements library</link>
        ). </para>
      <para> Another example of embedding TEI Publisher web components into a static website can be
        found on our <link xlink:href="https://teipublisher.onrender.com/">demo blog</link> . It was
        created with <link xlink:href="https://gohugo.io">Hugo</link> , a very popular website
        generator which offers hundreds of ready-made themes to choose from. Here content is written
        in markdown, but its not a problem to embed TEI content served by TEI Publisher. </para>
    </section>
  </section>

  <section xml:id="custom-components">
    <title>Creating Custom Web Components</title>
    <para> In some cases an app may need to add its own web components to the collection provided by
      TEI Publisher. Please consider following <emphasis role="bold">open-source-first approach</emphasis>
      , as we do, and contributing your component back to the community, for others to use. </para>
    <para> For that reason, we recommend here a setup which leads to relatively smooth integration
      with <code>pb-components</code> in the future. </para>
    <para> Start with forking and downloading the <code>pb-extension-template</code> package from
      its <link xlink:show="new" xlink:href="http://github.com/eeditiones/pb-extension-template">GitHub
      repository</link> . </para>
    <figure>
      <title>Visual Studio Code overview of pb-extension-template</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="component-extension.png" />
        </imageobject>
      </mediaobject>
    </figure>
    <para>You will find it already includes several configuration files to get you started on the
      development.</para>
    <itemizedlist>
      <listitem>
        <para>
          <filename>package.json</filename> file which includes definition and specifications for
          common task, like generating documentation or running a web server for local development </para>
      </listitem>
      <listitem>
        <para>
          <filename>src</filename> directory to put your custom web component code. It already
          includes <filename>pb-clipboard.js</filename> file as an example of a simple component </para>
      </listitem>
      <listitem>
        <para>
          <filename>index.html</filename> file which illustrates the simplest scaffolding for using
          your new components </para>
      </listitem>
      <listitem>
        <para>
          <filename>demo</filename> directory to place your demo files for testing and documentation
          purposes. It already contains <filename>demo.js</filename> configuration file and <filename>
          pb-clipboard.html</filename> demo for <tag>pb-clipboard</tag> . </para>
      </listitem>
      <listitem>
        <para>
          <filename>api.html</filename> file serving as a documentation starting point for your
          package </para>
      </listitem>
      <listitem>
        <para>
          <filename>rollup.config.js</filename> provides building specification to create a bundle
          that can be included in any web page. </para>
      </listitem>
    </itemizedlist>
    <para> To get you started, run <code>npm install</code> . This will install required
      dependencies: above all <code>pb-components</code> but also <code>es-dev-server</code> and <code>
      web-component-analyzer</code> packages which are needed for local development and
      documentation. </para>
    <figure>
      <title>Visual Studio Code snippet</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="litelem-vscode-snippet.png" />
        </imageobject>
      </mediaobject>
    </figure>
    <para> If you are using Visual Studio code <filename>.vscode/component.code-snippets</filename>
      will provide you with code templates. If you create a new file in <filename>src</filename> ,
      e.g. <filename>pb-foo.js</filename> and start typing <emphasis>litelement</emphasis> you will
      be offered a LitElement template. Otherwise you can copy the template manually or copy
      existing <tag>pb-clipboard</tag> element and tweak it. </para>
    <figure>
      <title>LitElement template</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="litelem-template.png" width="600px" />
        </imageobject>
      </mediaobject>
    </figure>
    <section xml:id="custom-components-clipboard">
      <title>pb-clipboard example</title>
      <para> We will discuss the details of the <tag>pb-clipboard</tag> element to illustrate some
        basic concepts. You will find exact code of this example in <code>
        pb-extension-template/src/pb-clipboard.js</code> . Each custom component has a defined API:
        an interface it presents to the outside world. It includes properties, methods (also called
        functions) and events but it bundles HTML markup along with local CSS and JavaScript into a
        single file. </para>
      <para> Our example is a custom element designed to provide simple <emphasis>copy-to-clipboard</emphasis>
        functionality, helpful e.g. when providing ready-made citation on a page. It consists of
        three parts: a label, the content to be copied and a button to copy. </para>
      <para>Thus, render function which actually displays this custom component could look like
        this:</para>
      <programlisting language="js" xml:space="preserve">
    render() {
        return html`
            &lt;h3&gt;${translate(this.label)}&lt;/h3&gt;
            &lt;div&gt;
                &lt;slot&gt;&lt;/slot&gt;
                &lt;paper-icon-button icon="icons:content-copy" @click="${this._copy}"
                    title="${translate('clipboard.copy')}"&gt;&lt;/paper-icon-button&gt;
            &lt;/div&gt;
        `;
    }
      </programlisting>
      <para> You will note that the render function uses not only regular HTML elements like <tag>h3</tag>
        or <tag>div</tag> but also components from the <code>paper-</code> package. To be able to
        use them, we need to explicitly import them. Same is true for <code>LitElement</code> class
        itself and important interface from the <code>pb-components</code> package: <code>pbMixin</code>
        . </para>
      <para> All user interface components may need to be localized. For that reason we also import <code>
        translate</code> method from TEI Publisher's <code>i18n</code> module. </para>
      <para>
        <code>LitElement</code> and <code>pbMixin</code> must be imported for all custom components
        extending <code>pb-components</code> . Code listing below demonstrates how to correctly
        import all classes and custom elements required as well as how to create a class signature
        that extends <code>pbMixin</code> . </para>
      <programlisting language="js" xml:space="preserve">
import { LitElement, html, css } from 'lit-element';
import { pbMixin } from '@teipublisher/pb-components/src/pb-mixin';
import { translate } from "@teipublisher/pb-components/src/pb-i18n";
import '@polymer/paper-icon-button';
import '@polymer/iron-icons';

/**
 * A component with a button which copies the contained content to the clipboard.
 * Use for the typical 'quote this content as' hints on a webpage.
 * 
 * @slot content - contains the actual content to copy to the clipboard
 */
export class PbClipboard extends pbMixin(LitElement) {
      </programlisting>

      <para> Imports and render function sorted, there are two other static functions we need to
        take care of: <function>properties</function> and <function>styles</function> . <code>
        pb-clipboard</code> has just a single property: the label to display above the copy text.
        Nevertheless it needs to explicitly declare properties inherited from pbMixin which is done
        via <code>...super.properties</code> notation. </para>
      <programlisting language="js" xml:space="preserve">
static get properties() {
        return {
            /**
             * Label to display above the text to be copied
             */
            label: {
                type: String
            },
            ...super.properties
        };
    }
      </programlisting>

      <para> You probably noticed that the button we added in the <function>render</function>
        function specifies what to do upon click event via <code>click</code> attribute: <code>
        @click="${this._copy}"</code> . A protected <function>_copy</function> function of the
        element is called in such case and for our simple <code>pb-clipboard</code> element it
        provides its core <emphasis>copy-to-clipboard</emphasis> functionality. </para>
      <programlisting language="js" xml:space="preserve">
/**
* Copy text content from the &lt;slot&gt; to the clipboard
*/

    _copy() {
        const slot = this.shadowRoot.querySelector('slot');
        
        // first import nodes from the slot into a temporary div
        const content = document.createElement('div');
        slot.assignedNodes().forEach((node) =&gt; {
            content.appendChild(document.importNode(node, true));
        });
        
        // copy the innerText of the temp div into the clipboard
        navigator.clipboard.writeText(content.innerText);
    }
      </programlisting>

      <para> We glanced over yet another interesting function invoked in the <code>render</code>
        method. <code>translate</code> , which accepts as an argument a key identifying a
        corresponding label in i18n language files. It could be one of keys shipping with TEI
        Publisher, but here, for a new component we need a more specific label, presenting the user
        with a short, informative text to be displayed when hovering over <emphasis>
        copy-to-clipboard</emphasis> button. Obviously, the label should change in line with the
        language setting for the whole application, which is why we need the i18n module in the
        first place. </para>
      <programlisting language="js" xml:space="preserve">
        title="${translate('clipboard.copy')}"
      </programlisting>
      <para> Please refer to the chapter on <link linkend="i18n">i18n</link> for in-depth discussion
        of the subject. Here we'll just mention that additional language files for new components
        should be placed in <filename>i18n/app</filename> , mimicking the location and format of
        Publisher. </para>
      <programlisting language="js" xml:space="preserve">
{
  "clipboard": {
     "label": "Quote  as:",
     "copy": "Click to copy to clipboard"
  }
}
      </programlisting>
      <para>And one last job is a little bit of styling to make things pretty.</para>
      <programlisting language="js" xml:space="preserve">
static get styles() {
        return css`
            :host {
                display: block;
            }
            h3 {
                margin: 0;
                font-size: .85em;
                font-weight: normal;
                color: #3a3a3a;
            }
            div {
                display: flex;
                align-items: center;
                padding: 0 16px;
            }
        `;
    }
      </programlisting>
      <para> The final directive at the very bottom of <filename>pb-clipboard.js</filename> is
        necessary to register the custom element with the browser. </para>
      <programlisting language="js" xml:space="preserve">
        customElements.define('pb-clipboard', PbClipboard);
      </programlisting>
    </section>
    <section xml:id="custom-components-testing">
      <title>Testing pb-clipboard</title>
      <para> Have a look at the supplied <filename>index.html</filename> example. Run <code>npm
        start</code> to run a simple <link xlink:show="new"
          xlink:href="https://www.npmjs.com/package/es-dev-server">local server</link> instance
        which allows to test our developments as we work on them without bundling. </para>
      <para> Opening <filename>index.html</filename> with this server you can see <tag>pb-clipboard</tag>
        in action. </para>
      <programlisting language="html" xml:space="preserve">
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Using pb-clipboard&lt;/title&gt;
        &lt;style&gt;
            pb-clipboard {
                margin-bottom: 20px;
            }
        &lt;/style&gt;
        &lt;script type="module" src="src/pb-clipboard.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Using pb-clipboard&lt;/h1&gt;
        &lt;pb-clipboard label="Quote as:"&gt;John Doe: "The miracles of foobar", Paradise Publishers, Little Village, Stardate 46254.7&lt;/pb-clipboard&gt;
        &lt;input type="text" name="test-clipboard" value="" size="60"&gt;
    &lt;/body&gt;
&lt;/html&gt;
      </programlisting>
      <para> In order to use the element, you need to import the component code into your HTML page,
        as demonstrated with the <tag>script</tag> and <code>src="src/pb-clipboard.js"</code> . </para>
      <para> It's all that is needed to use <tag>pb-clipboard</tag> as any other HTML element. Its
        label property is specified via <code>@label</code> attribute and the copy text is just the
        text content of the element. </para>
      <para>Pressing the button copies the citation text from the page and, just to test, you can
        paste it into the input box below.</para>
      <figure>
        <title>pb-clipboard in action on the es-dev-server</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="pb-clipboard-action.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section xml:id="custom-components-api">
      <title>API documentation</title>
      <para> Implementing a new feature is only half of the task - and sometimes the easier bit. All <code>
        pb-components</code> come with their API documentation and most of them also with one or
        more Demo showcases. Have a look e.g. at <tag>pb-collapse</tag> component for a simple one
        and compare with much more elaborate sections devoted to <tag>pb-toggle-feature</tag> or <tag>
        pb-select-feature</tag> . </para>
      <figure>
        <title>Initial part of the API tab of pb-collapse documentation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="api-docs.png" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> API documentation is generated automatically by <code>npm docs</code> task. You just
        need to add <link xlink:show="new"
          xlink:href="https://www.npmjs.com/package/web-component-analyzer#%E2%9E%A4-how-to-document-your-components-using-jsdoc">documentation-style
        comments</link> in your code. Example below illustrates how to nest code examples or specify
        slots and events so they are picked by the documentation generator. </para>
      <programlisting language="js" xml:space="preserve">
/**
 * This is a documentation-style comment
 *
 * with code example
 * ```html
 * &lt;pb-foo&gt;
 *   &lt;slot&gt;&lt;/slot&gt;
 *   &lt;div slot="foo-content"&gt;
 *       Foo bar
 *   &lt;/div&gt;
 * &lt;/pb-foo&gt;
 * ```
 * slots specification:
 *
 * @slot - unnamed default slot
 * @slot foo-content - content to be shown when foo happens
 *
 * events specification:
 * 
 * @fires pb-foo-open - Fires opening the foo section
 */
      </programlisting>
      <section xml:id="custom-components-demo">
        <title>Demo</title>
        <para>We encourage you to prepare a demo entry for each newly created component. Demo
          ideally presents one or more use case examples which illustrate where and how would you
          use a component. Keep the demo page simple and minimal, so other elements do not obstruct
          understanding the code.</para>
        <figure>
          <title>Demo file for pb-clipboard</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="api-docs-demo.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <para> Save your demo files in <filename>demo</filename> directory and register it in <filename>
          demo/demos.json</filename> with the demo filename and your chosen label for the tab (but
          please stick to Demo if you only have one). </para>
        <programlisting language="js" xml:space="preserve">
"pb-collapse": {
  "demo/pb-collapse.html": "Demo"
}
        </programlisting>
        <para>If you supply a number of demo files, choose meaningful labels for tabs, e.g.</para>
        <programlisting language="js" xml:space="preserve">
"pb-toggle-feature": {
  "demo/pb-toggle-feature.html": "Server-side with pb-view",
  "demo/pb-toggle-feature2.html": "Client-side",
  "demo/pb-toggle-feature3.html": "Server-side with pb-load"
}
        </programlisting>
      </section>
    </section>
    <section xml:id="custom-components-bundle">
      <title>Bundling and distribution</title>
      <para> Any new component <emphasis role="bold">must</emphasis> be explicitly imported by <filename>
        pb-extension-bundle.js</filename> . </para>
      <programlisting language="js" xml:space="preserve">
        import './src/pb-clipboard.js';
      </programlisting>
      <para> Run <code>npm build:production</code> to generate a distribution bundle. The generated
        library (located in <filename>dist</filename> ) will include everything, including the
        version of the <code>pb-components</code> library you are building upon and all
        dependencies. As a result, you can use it as a drop-in replacement for <code>pb-components</code>
        package: in your custom project, for TEI Publisher itself or Publisher-generated custom
        apps. </para>
    </section>
    <section xml:id="custom-components-using">
      <title>Using pb-extension-bundle in TEI Publisher or other apps</title>
      <para> The created library can be used as a drop-in replacement for the default <code>
        pb-components</code> library. </para>
      <para>To do so:</para>
      <procedure>
        <step>
          <para> clone <code>tei-publisher-app</code> or the generated app you would like to modify </para>
        </step>
        <step>
          <para> edit <filename>package.json</filename> and replace the dependency for <parameter>
            @teipublisher/pb-components</parameter> with the replacement library </para>
        </step>
        <step>
          <para> edit <filename>build.properties</filename> and change <parameter>scripts.dir</parameter>
            to point to the replacement library </para>
        </step>
        <step>
          <para> call <code>ant</code> to build <code>tei-publisher-app</code>
          </para>
        </step>
      </procedure>

      <para> For example, to use the git source of <code>pb-extension-template</code> in <filename>
        package.json</filename> , change the dependencies as follows: </para>
      <programlisting language="js" xml:space="preserve">
"dependencies": {
   "@teipublisher/pb-extension-template": "git+https://github.com/eeditiones/pb-extension-template#master"
} 
        </programlisting>
      <para> then change <filename>build.properties</filename> to contain: </para>
      <programlisting language="js" xml:space="preserve">scripts.dir=node_modules/@teipublisher/pb-extension-template/dist</programlisting>

      <para> Building <code>tei-publisher-app</code> should then copy scripts and resources from <code>
        pb-extension-template</code> instead of <code>pb-components</code> . </para>

      <note>
        <title>Note</title>
        <para> Make sure to adjust the repository link and name of the extension module to the one
          you created. Example above assumes working directly with <code>pb-extension-template</code>
          but it's unlikely to be the case in real life. </para>
      </note>
    </section>

  </section>

  <section xml:id="new-vocabulary">
    <title>Adding a custom vocabulary</title>
    <para>As discussed in the opening chapter, publishing a corpus of documents online is much more
      than just transforming a single source document into the desired output format. To fully
      support a new XML vocabulary in TEI Publisher several aspects need to be adressed:</para>
    <itemizedlist>
      <listitem>
        <para>ODD with processing models</para>
      </listitem>
      <listitem>
        <para>default view and page template</para>
      </listitem>
      <listitem>
        <para>navigation, breadcrumbs and table of contents</para>
      </listitem>
      <listitem>
        <para>search and filtering: full text index definitions, facets and fields</para>
      </listitem>
    </itemizedlist>
    <para>ODD and processing models within it govern how the document in your new vocabulary will be
      transformed into a range of available output formats: HTML, ePub etc.</para>
    <para> All other aspects are interconnected and depend on the understanding what constitutes the
      basic unit of the text: TEI primarily considers <emphasis>divisions</emphasis> or <emphasis>
      pages</emphasis> , DocBook rather <emphasis>sections</emphasis> . Therefore navigation for TEI
      document will be switching between <tag>div</tag> s or reconstructed XML fragments between
      subsequent <tag>pb</tag> s, while talking about pages in DocBook documents makes no sense and <tag>
      section</tag> s are the main structural units. </para>
    <para> This structure has its consequences for further aspects: generating TOC in TEI will
      analyze nested <tag>div</tag> / <tag>head</tag> structures but only <tag>section</tag> / <tag>
      title</tag> in DocBook. Likewise, KWIC display in TEI will be showing matches in <tag>div</tag>
      context but <tag>section</tag> in DocBook, so Lucene indexes need to be defined on these
      elements in their appropriate namespaces. Ditto for facets and fields used for sorting and
      filtering. </para>
    <para>Sections below will explain where and how to customize these aspects in more detail.</para>
    <section xml:id="new-vocabulary-odd">
      <title>ODD</title>
      <para> Create a new, blank ODD file which is not chained to any other ODD and add <tag>
        elementSpec</tag> s for its elements. Make sure that you specify correct namespace for your
        vocabulary. Optionally, you can also specify an external CSS file with style declarations
        for classes and elements you will be using in processing models of your ODD. </para>
      <para>See how it looks in the ODD for DocBook.</para>
      <figure>
        <title>ODD for DocBook</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="new-vocabulary-odd.png" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> When adding models into the custom ODD for your vocabulary it is recommended that at
        least one element applies the <parameter>document</parameter> behaviour. Usually it will be
        the top level element or the main content-bearing one (like <tag>article</tag> in DocBook). </para>
      <para> This is not strictly required but for print output via LaTeX or FO the <parameter>
        document</parameter> behaviour specifies default prologue governing basic setup for PDF. If
        you refer to the <filename>docbook.odd</filename> you will note that the same effect is
        achieved by explicitly defining the prologue in the <tag>pb:template</tag> for <parameter>
        article</parameter> . </para>
      <section xml:id="new-vocabulary-foo">
        <title>Case study: foo vocabulary</title>
        <para> Let's consider an imaginary vocabulary called <emphasis>foo</emphasis> . All
          documents in this vocabulary will belong to the <code>http://foo.io</code> namespace.
          Simple document could look as follows: </para>
        <programlisting language="xml" xml:space="preserve">
        &lt;fooStart xmlns="http://foo.io"&gt;
          &lt;foo&gt;My foo document&lt;/foo&gt;
          &lt;bar&gt;About something very important for foo community.&lt;/bar&gt;
        &lt;/fooStart&gt;
        </programlisting>
        <para> Let's save this document in the <filename>playground</filename> collection as <filename>
          foo.xml</filename> . </para>
        <para> Unfortunately a request to retrieve this document in Publisher fails with <emphasis>the
          server did not return any content</emphasis> error message. </para>
        <programlisting>http://localhost:8080/exist/apps/tei-publisher/playground/foo.xml</programlisting>
        <para> Fixing this will require creating a new ODD for <emphasis>foo</emphasis> vocabulary. </para>
        <para> Create a new ODD as described previously. Use <parameter>document</parameter>
          behaviour for <tag>fooStart</tag> element and perhaps <tag>inline</tag> with an <tag>
          outputRendition</tag> set to <parameter>italic</parameter> for <tag>foo</tag> element.
          Please note to specify the ODD for your vocabulary. </para>


        <para> Very bare bones ODD file for a fictional <emphasis>Foo</emphasis> vocabulary could
          look as follows: </para>
        <figure>
          <title>ODD for Foo</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="foo-odd.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Or, in XML form:</para>
        <programlisting language="xml" xml:space="preserve">
&lt;schemaSpec start="fooStart" ident="foo" ns="http://foo.io"&gt; 
   &lt;elementSpec ident="foo" mode="add"&gt;
       &lt;model behaviour="inline"&gt;
           &lt;outputRendition&gt;font-style: italic;&lt;/outputRendition&gt;
       &lt;/model&gt;
   &lt;/elementSpec&gt;
   &lt;elementSpec ident="fooStart" mode="add"&gt;
       &lt;model behaviour="document"/&gt;
   &lt;/elementSpec&gt;
&lt;/schemaSpec&gt;
        </programlisting>
        <para> With this in place we could reformulate our request to explicitly specify the ODD to
          use and a <parameter>single</parameter> view. </para>
        <programlisting>http://localhost:8080/exist/apps/tei-publisher/playground/foo.xml?odd=foo&amp;view=single</programlisting>
        <figure>
          <title>foo.xml rendered with foo.odd in single view</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="foo-single-view.png" />
            </imageobject>
          </mediaobject>
        </figure>
        <note>
          <title>Note</title>
          <para> It is necessary to use <parameter>single</parameter> view along with the <parameter>
            foo.odd</parameter> . Otherwise, the app default view would be used, which in TEI
            Publisher is normally set to <parameter>div</parameter> . As we already mentioned,
            implementation of view parameters needs to be vocabulary-specific to work. Since <emphasis>
            foo</emphasis> vocabulary doesn't yet have navigation customized, TEI Publisher will
            fall back to TEI and try to locate <tag>tei:div</tag> elements, which obviously cannot
            be found in our test document in foo namespace. </para>

        </note>
      </section>

    </section>
    <section xml:id="new-vocabulary-default-view">
      <title>Default view and page template</title>
      <para> Rendering of the document is governed by a number of parameters, particularly <parameter>
        view</parameter> , <parameter>ODD</parameter> and <parameter>template</parameter> : </para>
      <para> Even when these parameters are not explicitly specified, TEI Publisher and apps
        generated from it, will fall back to the default values specified in <filename>
        modules/config.xqm</filename> . </para>

      <itemizedlist>
        <listitem>
          <para> ODD: <code>$config:default-view</code>
          </para>
        </listitem>
        <listitem>
          <para> view: <code>$config:default-view</code>
          </para>
        </listitem>
        <listitem>
          <para> template: <code>$config:default-template</code>
          </para>
        </listitem>
      </itemizedlist>
      <para> Alternative way to specify these would be using a <link linkend="pi-config">processing
        instruction</link> in the foo.xml document itself. </para>
      <programlisting language="xml" xml:space="preserve">
        &lt;?teipublisher odd="foo.odd" view="single" template="view.html"?&gt;
      </programlisting>
    </section>
    <section xml:id="new-vocabulary-lucene">
      <title>Lucene configuration</title>
      <para>eXist-db and TEI Publisher make extensive use of Lucene indexing engine. In particular
        search, navigation, sorting and filtering heavily depend on full text indexes, facets and
        fields. It is therefore paramount to specify these correctly for your data collection.</para>
      <para> Supporting a new vocabulary, make sure to add its namespace on the <tag>index</tag>
        element in <filename>collection.xconf</filename> . </para>
      <programlisting language="xml" xml:space="preserve">
&lt;index xmlns:tei="http://www.tei-c.org/ns/1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dbk="http://docbook.org/ns/docbook"&gt;
      </programlisting>
      <para>Beyond this minor adjustment, adding a new vocabulary does not differ in creation and
        use of facets and fields.</para>
    </section>
    <section xml:id="new-vocabulary-navigation">
      <title>Navigation</title>
      <para>We have extensively covered modifications to the ODD and page templates in earlier
        chapters. In case of vocabularies without out-of-the-box Publisher support it is necessary
        to customize the navigation as well. Tacit understanding of document's structure is critical
        for many kinds of user interactions - from browsing through pages to creating the table of
        contents.</para>
      <para>
        <filename>modules/navigation.xql</filename> is the main "control room" for all tasks related
        to navigation. You will note that it imports custom modules for all supported vocabularies: <emphasis>
        TEI</emphasis> , <emphasis>JATS</emphasis> and <emphasis>DocBook</emphasis> . All requests
        are dispatched to specialized modules, depending on the namespace of the document (cf. <function>
        config:document-type</function> function). </para>
      <programlisting language="xquery" xml:space="preserve">
module namespace nav="http://www.tei-c.org/tei-simple/navigation";

import module namespace tei-nav="http://www.tei-c.org/tei-simple/navigation/tei" at "navigation-tei.xql";
import module namespace jats-nav="http://www.tei-c.org/tei-simple/navigation/jats" at "navigation-jats.xql";
import module namespace docbook-nav="http://www.tei-c.org/tei-simple/navigation/docbook" at "navigation-dbk.xql";
      </programlisting>
      <para>Customizing yet unsupported vocabulary will require:</para>
      <itemizedlist>
        <listitem>
          <para> create a new navigation module for the new vocabulary (e.g. <filename>
            navigation-foo.xql</filename> ; it should implement all the functions that <function>
            navigation.xql</function> dispatches to; you can use <filename>navigation-tei</filename>
            as a starting point for customization </para>
        </listitem>
        <listitem>
          <para> import it into <filename>navigation.xql</filename>
          </para>
        </listitem>
        <listitem>
          <para> adjust <function>config:document-type</function> function </para>
        </listitem>
        <listitem>
          <para> adjust <function>nav:get-root</function>
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="new-vocabulary-search">
      <title>Search</title>
      <para> Full text search is realized via the same modular approach that governs navigation. <filename>
        modules/query.xql</filename> is the main "control room", dispatching requests to functions
        in specialized modules. See implementation of <filename>query-db.xql</filename> or <filename>
        query-tei.xql</filename> before creating a dedicated module for your vocabulary. Make sure
        to import your module into <filename>query.xql</filename> . </para>
    </section>

  </section>
  <section xml:id="web-annotations">
    <title>Annotating Documents</title>
    <para>Since version 7.1.0, TEI Publisher supports annotating TEI documents via a graphic, web
      based interface. This means you can enhance existing TEI documents directly within TEI
      Publisher in a user-friendly environment where XML code is neatly hidden from sight when not
      needed.</para>
    <para>The annotation editor is not meant for creating documents from scratch but targets one of
      the most tedious and time consuming tasks in any edition project: adding semantic, analytic or
      text-critical markup to an existing transcription.</para>
    <figure>
      <title>Annotation editor</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="ann-overview.png" width="900px" />
        </imageobject>
      </mediaobject>
    </figure>
    <para>Typical workflow for many projects will resemble the following:</para>
    <orderedlist>
      <listitem>
        <para>An initial transcription is created, either manually in a text editor, or using OCR or
          HTR tools like Transkribus. It contains the basic structural markup, i.e. divisions,
          headings, paragraphs etc.</para>
      </listitem>
      <listitem>
        <para>That initial transcription is gradually enriched: textual features like emphasis can
          be marked, abbreviations expanded, corrections and regularizations applied; people, places
          or terms appearing in the text can be explicitly tagged and linked to an authority; dates
          or measures normalized. This is an iterative process: the resulting TEI encoding is
          constantly reviewed, which may result in further changes to be made.</para>
      </listitem>
    </orderedlist>
    <para>Web annotations try to ease the burden of the enrichment phase by allowing editors to mark
      everything directly within the user-friendly environment, closely resembling the publication
      view. It is much easier to read and doesn't require half as much TEI experience as using an
      XML editor. Just use your mouse to highlight the text fragment to annotate, click on the
      annotation type and optionally select additional information, e.g. to link with an external
      authority file.</para>
    <section>
      <title>Prerequisites and considerations</title>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Browsers</emphasis></para>
          <para>The annotation editor requires a modern browser like Firefox, Chrome or a
            Chrome-based browser like the newest Edge on Windows 10. <emphasis>Safari</emphasis>
            will not work due to a known bug in text selection, which Apple seems reluctant to fix.</para>
          <para>Directly exporting the resulting text to a directory of the user's choice, is
            currently only supported in Chrome.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Division size</emphasis></para>
          <para>The editor should work fine for texts up to the length of a journal article or
            chapter. Really long texts (e.g. a whole book) will be automatically split by top
            divisions, but you may still experience a recognizable time lag for long divisions.</para>
        </listitem>
      </itemizedlist>
      <para>Annotations have been extensively tested, and should work reliably for tagging entities
        and other inline markup. You may want to keep an eye on the resulting TEI when testing
        annotations on your material. We appreciate bug reports and suggestions for improvement.</para>
    </section>
    <section>
      <title>Annotations: the pen and paper of the digital world</title>
      <para>How the annotation editor works is easy to understand if you imagine reviewing a text
        the old-fashioned way: print it out, then use a marker to highlight certain passages, write
        corrections over the text with a pen, or scribble notes into the margin. Once back at your
        computer, all the changes need to be transferred into the TEI. You may then continue with a
        second round of review by printing out the results again.</para>

      <para>Within our electronic environment, the printout corresponds to the source TEI document
        and the marks and scribbles are annotations. Until you explicitely merge the annotations
        into the source TEI, they will be kept separate from the document they apply to. Once
        merged, a new version of the source TEI document is established and the editing process
        restarts.</para>
      <para>Notably, TEI Publisher is able to detect existing markup in the base text when it is
        loaded. Any markup corresponding to a known annotation type will be recognized and displayed
        as such, therefore it can be modified. In this sense it is slightly different from working
        with pen and paper.</para>
      <para>From the printout example it should be clear that you cannot change the printed text
        itself (unless you had some magic paper). Accordingly, annotations are not allowed to change
        the base text, i.e. the text "printed" on the screen. If you want to explicitly indicate a
        correction, you can use the <emphasis>corr</emphasis> or <emphasis>reg</emphasis> annotation
        type, which corresponds to the TEI encoding with choice/sic/corr or choice/orig/reg. </para>
      <para>You can use annotations for virtually any kind of inline markup. The only strict
        requirement is that the <emphasis>base text</emphasis>, our source document, remains stable <emphasis>during
        an editing session</emphasis> i.e. until annotations are merged. The reason for that is the
        annotations are anchored to a certain position in the document, so any changes to it would
        mean that our coordinates might suddenly point to different fragments.</para>
      <para>That said, there's also a special <emphasis>edit</emphasis> annotation type, which does
        allow you to perform limited editing of a text. It will just "seamlessly" change the
        transcription text fragment without adding any explicit markup. Nevertheless, such a change
        to the TEI document is only applied when you merge and therefore establish a new base text.
        The limitation is that only text fragments can be edited: the boundaries of structural
        markup or annotations may not be crossed. It can be convenient for fixing a typo in a
        transcription that wasn’t caught when the base text was prepared.</para>
      <para>You also cannot use the annotation editor to modify the structural markup of the base
        text, i.e. block-level elements like divs, paragraphs, headings or notes. In case you need
        to change the structure, you have to merge your annotations first, saving a new version of
        the TEI document and switch to an XML editor to change the XML there. The new document can
        be then reloaded into the annotation editor and you can continue.</para>
      <para>As already indicated, it is possible to handle common nested encoding structures like <tag>
        choice</tag> or <tag>app</tag> as annotations. Nevertheless the inner elements, i.e. <tag>
        lem</tag>, <tag>rdg</tag>, <tag>sic</tag>, <tag>corr</tag> or <tag>orig</tag>, <tag>reg</tag>,
        need to have simple text content: they cannot be annotated themselves (at least not in the
        current version).</para>
    </section>
    <section>
      <title>Applying Annotations</title>
      <para>To start annotating a document, select or upload one into the annotations collection in
        TEI Publisher.</para>
      <figure>
        <title>Annotation playground</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ann-playground.png" width="900px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Selecting any document in this collection will load the annotation view. This view is
        split into three areas:</para>
      <orderedlist>
        <listitem>
          <para>a sidebar to the left, initially showing only a toolbar with a disabled button for
            each annotation type</para>
        </listitem>
        <listitem>
          <para>the annotation view in the middle, displaying the text content to be annotated</para>
        </listitem>
        <listitem>
          <para>a preview panel to the right: this is initially empty, but will come to life once
            you start making annotations</para>
        </listitem>
      </orderedlist>
      <figure>
        <title>Annotation view</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ann-init.png" width="900px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>To annotate a certain passage, select it with your mouse. The toolbar buttons in the
        left sidebar now become active. Choose an annotation by clicking the corresponding button or
        using a keyboard shortcut. Hovering over buttons you can see an info text with a brief
        description and a keyboard shortut.</para>
      <figure>
        <title>Annotation types</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ann-types.png" width="300px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Depending on the chosen annotation type, a form will appear beneath the toolbar. We
        distinguish three categories of annotations: <orderedlist>
          <listitem>
            <para>semantic annotations, which are (usually) connected to an external authority, e.g.
        for people, places, organizations or terms.</para>
          </listitem>
          <listitem>
            <para>"toggle" annotations, which do not need require additional information, so they
        simply switch an annotation on/off, e.g. for deletions or titles (not part of the default
        annotation editor setup).</para>
          </listitem>
          <listitem>
            <para>analytic or text critical annotations, which may require further input from the
        user, e.g. a normalized date.</para>
          </listitem>
        </orderedlist> These
        categories are not mutually exclusive but may be helpful to explain the main functional
        differences between the three use scenarios. </para>
      <section>
        <title>Semantic Annotations</title>
        <para>Semantic annotations include markup for entities like people, places or terms. Most
          editions will try to link those to a description of the entity, either provided by an
          external authority file or from a local resource. In any case you will want to reference a
          unique identifier to mark occurrences of the same entity throughout the edition.</para>
        <para>When choosing a semantic annotation from the toolbar, you will thus see a dialog which
          runs a query against the authority file configured for the annotation type, e.g. Geonames
          for places or GND for people. </para>
        <figure>
          <title>Annotating a person</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="ann-person.png" width="800px" />
            </imageobject>
          </mediaobject>
        </figure>
        <para>The semantic annotation dialog displays the query results for you to choose from and
          the query sent initially corresponds to the text selection made. Often this may not find
          the relevant entity, but you can change the query in the input field on top of the dialog
          and run the search again by pressing enter. Compare the screenshots above and below to
          note the difference when searching for <emphasis>William</emphasis> vs <emphasis>William
          Graves</emphasis></para>
        <figure>
          <title>Re-running the query</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="ann-person2.png" width="800px" />
            </imageobject>
          </mediaobject>
        </figure>
        <para>When you use the + sign to select an authority entry, its ID will be copied into the
          top input field in the left sidebar and a short description of the entity should appear
          beneath. The ID will be used as reference in the resulting TEI, i.e. it will appear in an
          attribute attached to e.g. <tag>persName</tag> or other TEI element. The exact mapping
          between an annotation type and a TEI snippet produced can be freely configured (see
          below).</para>
        <para>Semantic annotations are stored in the annotation list immediately after you select an
          authority entry, so you don't have to click anywhere else.</para>
        <para><emphasis role="bold">Batch edits and suggestions</emphasis></para>
        <para>It is not uncommon that the same person will be mentioned multiple times in a
          document. To simplify and speed up the editing process, the annotation editor tries to
          detect possible other occurrences of the currently selected entity throughout the
          document. A list of potential matches is presented at the bottom of the left sidebar.</para>
        <para>The list is compiled by traversing the text shown on screen, searching for strings
          which may indicate the same entity. The actual query depends on the information provided
          authority used: e.g. if the authority supplies alternative names, those will be added to
          the searched for strings.</para>
        <para>Each occurrence will show a checkbox to the left. Checking it will immediately tag the
          corresponding passage as another instance of the same entity. You can also check all boxes
          at once by clicking on the icon to the top right above the list.</para>
        <para>Moving your mouse over an entry will scroll the text to the corresponding occurrence,
          showing you the match in its context.</para>
        <para>Existing annotations referencing the same entity will also be shown in the list - with
          their checkbox checked. Sometimes you may also see an entry with red dots beneath,
          indicating that this is an existing annotation referencing a different entity, so
          considered a potential inconsistency to review. For example, if you selected the authority
          entry for "Ronald Reagan", you may see other occurrences of "Reagan", which have already
          been annotated as "Nancy Reagan". You will see those occurrences underlined with red dots.
          You can switch them to "Ronald Reagan" by checking their box.</para>
        <para>Unchecking a box will remove the existing annotation, e.g. incorrectly applied one.</para>
        <figure>
          <title>Inconsistency warning</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="ann-reagan.jpg" width="800px" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section>
        <title>Toggle Annotations</title>
        <para>Toggle annotations are immediately applied when you click the annotation button. Since
          they do not require any further input they are just simply applied without much ado. Some
          good candidates might be titles or deletions. </para>
        <para>It is worth noting that it's not a textual phenomenon that constitutes a <emphasis>
          toggle</emphasis> annotation versus <emphasis>semantic</emphasis> or <emphasis>analytic</emphasis>
          in our simple category scheme. It is rather what kinds of detail a particular project
          decides to encode or not. Encoding of titles can be a <emphasis>toggle</emphasis> if we
          just decide to simply say that a text fragment is a title. It could become a <emphasis>
          semantic</emphasis> annotation if we'd like to associate it with a bibliographical
          reference or other detailed information. </para>
      </section>
      <section>
        <title>Analytic and Text Critical Annotations</title>
        <para>These annotations are not connecting to an authority reference, but typically require
          further input to be made by the user. For example a <tag>date</tag> annotation requires
          the editor to supply a normalized date, while normalizations, abbreviations and
          corrections need regularized, expanded or corrected form, respectively. Apparatus entries
          will require all the variant readings. For all these annotations an input form will be
          shown into which such information can be entered. The exact content of the form depends on
          the annotation type.</para>
        <para>To store the annotation, you must click on the save button beneath the form after
          filling the required fields.</para>
        <figure>
          <title>Correction</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="ann-correction.png" width="800px" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section>
      <title>Modifying Annotations</title>
      <para>The annotation view shows a colored line beneath the text spanned by each annotation.
        You can select text within an existing annotation or across multiple different ones and
        apply yet another annotation to it, thus resulting in <emphasis>nested annotations</emphasis>.
        However, the editor will ensure that you do not select partial elements, for example, a
        range of text followed by half of a <tag>persName</tag>. This would result in invalid XML,
        so the editor will automatically expand your selection to include the entire <tag>persName</tag>
        .</para>
      <figure>
        <title>Nested annotations</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ann-nested.png" width="600px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>To the right of the annotated text, a colored box indicates the type of the annotation.
        The sequence of boxes also indicates how annotations are nested: the ones appearing to the
        right are wrapping those to the left. In the example above the "church of San Francisco" is
        a reference to a place, while "San Francisco" refers to a person, a patron saint of the
        church. The <tag>persName</tag> element is nested in the <tag>placeName</tag>.</para>
      <para>Click on the colored box to see details about the annotation. For semantic annotations,
        the details will include a summary of the entity drawn from the connected authority or the
        local TEI register. For analytic and text critical annotations, a table is shown, listing
        the corresponding attributes associated with the annotation.</para>
      <figure>
        <title>Annotation details</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ann-details.png" width="800px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>The toolbar at the bottom of the popup allows to delete or modify the annotation.
        Clicking the delete button will immediately remove the annotation, without asking for
        confirmation.</para>
      <para>Clicking on the pen icon will open the annotation in the left sidebar, where you can
        change it. For semantic annotations, the authority lookup dialog will pop up automatically
        and you can change the connected authority entry by selecting a different one.</para>
      <para>Again, semantic annotations are applied immediately, while analytic and text critical
        annotations require a click on the save button after making modifications.</para>
    </section>
    <section>
      <title>The Preview Pane</title>
      <para>Whenever you add, remove or edit an annotation, the preview pane to the right will show
        you an updated preview of your changes. It shows<orderedlist>
          <listitem>
            <para>the resulting HTML, i.e. how your document would display in TEI Publisher if the
        annotations were merged, rendered through the ODD associated with the document</para>
          </listitem>
          <listitem>
            <para>the TEI of the entire document if annotations were merged</para>
          </listitem>
          <listitem>
            <para>the internal JSON structure representing the annotations (for debugging purposes)</para>
          </listitem>
          <listitem>
            <para>the TEI fragments which would be changed if annotations were merged</para>
          </listitem>
        </orderedlist></para>
      <para>The preview does not actually change the TEI source document: it just applies the
        annotations in memory, leaving the source untouched. It just allows you though to check if
        annotations will be applied in the correct way.</para>
      <figure>
        <title>HTML preview</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ann-preview.png" width="800px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>The annotation text view in the middle and the preview HTML panel to the right, both
        render the document through ODD. However, they use different ODDs: the annotation view
        renders the text through a dedicated ODD (annotations.odd) to make sure that all relevant
        bits of the base text are displayed and there's no hidden information, which would be
        inaccessible to the editor. The preview HTML panel simply uses the ODD associated with the
        document (or the base teipublisher.odd otherwise).</para>
    </section>
    <section>
      <title>Merge, Export and Undo</title>
      <para>The toolbar on top of the preview pane provides important actions: <figure>
          <title>Toolbar</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="ann-toolbar.png" width="500px" />
            </imageobject>
          </mediaobject>
        </figure>
      <variablelist>
          <varlistentry>
            <term>Reload source TEI</term>
            <listitem>
              <para>This will reload the source TEI XML into the annotation view, discarding any
        existing annotations. Use this if you had to change the TEI in an external editor and want
        to continue annotating.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Merge and save annotations to TEI</term>
            <listitem>
              <para>Merges the current set of annotations into the TEI and saves it, establishing a
        new version of the base document. The annotation view will be reloaded to reflect the new
        base.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Save and export TEI to a local file</term>
            <listitem>
              <para>(Chrome only) As above, merges and saves the annotations, but additionally
        prompts for a local file into which a copy of the resulting TEI will be written.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Undo last change</term>
            <listitem>
              <para>Reverts the last action applied. For batch operations (if you clicked the "apply
        all" button above the occurrences list) this may comprise multiple annotations. The
        annotation view will be reloaded and the remaining annotations are re-applied.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Preview merge results</term>
            <listitem>
              <para>Forces the preview pane to refresh.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </section>
  </section>
  <section>
    <title>Configuring the Annotation Editor</title>
    <para>The annotation editor is fully configurable. This includes<orderedlist>
        <listitem>
          <para>the connectors used for authority lookups</para>
        </listitem>
        <listitem>
          <para>how authority entries can be extended with additional information</para>
        </listitem>
        <listitem>
          <para>how annotations are mapped to TEI elements</para>
        </listitem>
      </orderedlist></para>
    <para>If you would like to customize the editor for your own needs, we recommend to generate a <emphasis>separate
      application just for annotation purposes</emphasis>. This makes it easier to configure and you
      maintain a clear separation between data which is still being worked on and the final edition
      you want to show to users.</para>
    <para>To generate a separate application for annotations, select <guimenuitem>Admin</guimenuitem>
      /<guimenuitem>App Generator</guimenuitem>. In the form, make sure to choose the ODD called
      "Annotations" and select "Annotation Editing" as template.</para>
    <section>
      <title>Configuring Authorities</title>
      <para>In its current state, TEI Publisher supports the following external authorities for
        entity lookup:<variablelist>
          <varlistentry>
            <term>GeoNames</term>
            <listitem>
              <para><link xlink:href="https://www.geonames.org/"
                >geonames.org</link> - for places</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>GND</term>
            <listitem>
              <para><link xlink:href="https://gnd.network/">Gemeinsame Normdatei</link> via <link
                  xlink:href="http://lobid.org/"
                >lobid.org</link> - for people, organizations and
        terms</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Metagrid</term>
            <listitem>
              <para><link xlink:href="https://metagrid.ch/">metagrid.ch</link> - for people</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Airtable</term>
            <listitem>
              <para><link xlink:href="https://www.airtable.com/"
                >airtable.com</link> - arbitrary
        entities, each corresponding to a table</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Reconciliation</term>
            <listitem>
              <para><link xlink:href="https://reconciliation-api.github.io/testbench/"
                >Reconciliation
        Service</link> - arbitrary entities, provided by any reconciliation service</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>KBGA</term>
            <listitem>
              <para><link
                  xlink:href="https://theologie.unibas.ch/de/karl-barth-zentrum/gesamtausgabe/"
                >Karl
        Barth Gesamtausgabe</link> - for people, organizations, terms, abbreviations</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Custom</term>
            <listitem>
              <para>A custom connector, which delegates to one or more authorities, but also
        searches a local TEI register</para>
            </listitem>
          </varlistentry>
        </variablelist></para>
      <para>The HTML template defining the user interface of the annotations editor determines which
        authority is used for which annotation type and can be easily adjusted. Just edit the <filename>
        templates/pages/annotate.html</filename> file, which can be done in eXide (or any editor of
        your choice). A simple configuration looks as follows:</para>
      <programlisting language="xml" xml:space="preserve"><![CDATA[
<pb-authority-lookup subscribe="transcription" emit="transcription">
    <pb-authority connector="GND" name="organization" prefix="gnd"></pb-authority>
    <pb-authority connector="GeoNames" name="place" user="existdb" prefix="geo"></pb-authority>
    <pb-authority connector="GND" name="term" prefix="gnd"></pb-authority>
    <pb-authority connector="GND" name="person" prefix="gnd"></pb-authority>
</pb-authority-lookup>]]>
      </programlisting>
      <para>Each top-level pb-authority needs at least two attributes:<itemizedlist>
          <listitem>
            <para>a <option>name</option> indicating the annotation type for which it should be used</para>
          </listitem>
          <listitem>
            <para>a <option>connector</option>, which selects one of the authority connectors listed
        above</para>
          </listitem>
        </itemizedlist></para>
      <para>In addition, you may define a <option>prefix</option>: this will be prepended to the
        xml:id referenced by the resulting TEI element (separated by a hyphen "-"). For example, you
        may want to prefix the numeric IDs received from GND with the prefix "gnd" to obtain an XML
        ID like "gnd-124507514" since a number alone would not be a valid @xml:id.</para>
      <para>Some connectors require additional configuration attributes. At the moment those are the <emphasis>
        GeoNames</emphasis>, <emphasis>Airtable</emphasis> and <emphasis>Reconciliation</emphasis>
        connectors. GeoNames requires you to register a user, whose name is given in the <option>
        user</option> attribute and Reconciliation requires that you specify a service URL.</para>
      <para>The <emphasis>Airtable</emphasis>, <emphasis>Reconciliation</emphasis> and <emphasis>
        Custom</emphasis> connectors are described in more detail below.</para>
      <section>
        <title>Airtable Connector</title>
        <para><link xlink:href="https://www.airtable.com/"
          >airtable.com</link> is not an authority
          file as such, but rather a commercial online database, allowing users to define their own
          tables and forms. It can therefore be turned into an authority, e.g. by defining a <emphasis>
          people</emphasis> or <emphasis>places</emphasis> table and connecting it with the airtable
          connector. Since any kind of data can be stored in an airtable, a slightly more complex
          configuration is necessary to specify how to access relevant tables and extract the
          required information. An example configuration for a single table is shown below:</para>
        <programlisting language="xml" xml:space="preserve">&lt;pb-authority connector="Airtable" name="topic" api-key="my-api-key" base="database-id" 
  table="Topics" fields="Name, Variants, Definition, Term Type" label="${Name}" 
  tokenize="Name, Variants" tokenize-regex="\s*;\s*"
  filter="or(find('${key}', lower({Name})), find('${key}', lower({Variants})))">
  &lt;template class="info">
    &lt;h3>${Name}&lt;/h3>
    &lt;p>
        ${Term Type}
        &lt;br/>
        ${Definition}
        &lt;br/>
        ${Variants}
    &lt;/p>
  &lt;/template>
  &lt;template class="detail">
    ${Term Type}. ${Definition}. ${Variants}.
  &lt;/template>
&lt;/pb-authority></programlisting>
        <para>This will retrieve authority entries from a table called 'Topics' using the columns
          Name, Variants, Definition and Term Type.</para>
        <variablelist>
          <varlistentry>
            <term>api-key</term>
            <listitem>
              <para>The personal API key obtained from your airtable.com user profile</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>base</term>
            <listitem>
              <para>The API key for your database</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>table</term>
            <listitem>
              <para>Name of the table to use</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>fields</term>
            <listitem>
              <para>A list of table column names to be retrieved as fields. Fields can be referenced
                in other configuration expressions using the <code>${column}</code> notation</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>label</term>
            <listitem>
              <para>The field or expression to use as main label when displaying authority lookup
                results</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>filter</term>
            <listitem>
              <para>The airtable formula to be used for searching</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>template class="info"</term>
            <listitem>
              <para>An HTML fragment to show when displaying a popover with annotation details in
                the annotation editor</para>
              <figure>
                <title>"Info" template in action</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="ann-airtable-info.png" width="500px" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>template class="detail"</term>
            <listitem>
              <para>HTML fragment to show as the detailed match description in the dialog presenting
                the results of querying the authority register</para>
              <figure>
                <title>"Detail" template in action</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="ann-airtable-detail.png" width="500px" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>tokenize</term>
            <listitem>
              <para>Defines which columns should be used when searching the text for other potential
                occurrences of the entity. For the search, the column values are split using the
                regular expression given in <option>tokenize-regex</option></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>tokenize-regex</term>
            <listitem>
              <para>an optional regular expression used to split values before searching the text
                for other occurrences. This is useful if you have variant names separated by , or ;
                and each variant should be searched for separately.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>Reconciliation Service Connector</title>
        <para>Like the airtable connector described above, the <link
            xlink:href="https://reconciliation-api.github.io/specs/latest/">Reconciliation Service</link>
          is not really an authority file itself. Rather, it is a communication protocol for
          authority data providers originally developed for the open-source data cleaning software <link
            xlink:href="openrefine.org/">OpenRefine</link>. The specification is an open, <link
            xlink:href="https://www.w3.org/community/reconciliation/"
          >community-maintained</link>
          standard now, and several authority data providers offer comforming API endpoints.
          GeoNames, the German GND (again via lobid), Getty vocabularies and Wikidata are some
          examples - find a list of current services at the <link
            xlink:href="https://reconciliation-api.github.io/testbench/">service testbench</link>.
          In addition to the general attributes described above, the only additional bit of
          configuration is the service URL that should be queried. You specify it in the "endpoint"
          attribute:</para>
        <programlisting language="xml" xml:space="preserve">&lt;pb-authority connector="Reconciliation" name="term" prefix="wd" endpoint="https://wikidata.reconci.link/api"/></programlisting>
        <para>This will retrieve authority entries from wikidata.</para>
        <para>Currently, the Reconciliation connector cannot be used as a data provider for the
          Custom connector described below. This will be added in a future release.</para>
      </section>
      <section>
        <title>Custom Connector</title>
        <para>The custom connector delegates queries to one or more authorities, but most
          importantly it creates a copy of every authority entry you select and writes it to a local
          TEI register.</para>
        <para>For many editions the information provided by an external authority will not be
          sufficient. It may be incomplete, in the sense it may lack important information relevant
          in the context of the edition but also many historical persons or places may not yet
          appear in any authority.</para>
        <para>Using the custom connector gives you a possibility to extend the information about an
          entity, or add new ones. This works as follows:<orderedlist>
            <listitem>
              <para>whenever you select an entry from the external authority, the custom connector
          creates a skeleton <tag>person</tag>, <tag>place</tag> or <tag>category</tag> TEI element
          in the local TEI registry (the exact location of the registry can be configured) using the
          information provided by the authority</para>
            </listitem>
            <listitem>
              <para>you can extend the local entry with additional information, e.g. add a note to
          explain why the person is important in the context of the edition</para>
            </listitem>
            <listitem>
              <para>any subsequent authority query will also search the local registry and matches
          found there will be ranked at the top of the results</para>
            </listitem>
            <listitem>
              <para>to support entites which do not exist in an external authority, just create an
          entry in the local registry and assign it a local xml:id</para>
            </listitem>
          </orderedlist></para>
        <para>To configure the custom connector, simply wrap it around the definition for the
          external authority you want to use, e.g.:</para>
        <programlisting language="xml" xml:space="preserve">&lt;pb-authority connector="Custom" name="person">
    &lt;pb-authority connector="GND" prefix="gnd">&lt;/pb-authority>
&lt;/pb-authority></programlisting>
        <para>This defines a custom connector for the annotation type 'person', delegating queries
          to the GND connector, but also maintaining a local registry. By default the local registry
          is stored in a TEI document residing in <filename>data/registry.xml</filename>. You can
          change the location by modifying the variable <varname>$anno:local-authority-file</varname>
          in the annotation configuration, <filename>modules/annotation-config.xqm</filename>. You
          can also change the function <function>anno:insert-point</function> to configure where
          exactly the local entity definitions will be stored.</para>
        <para>Currently, it is not possible to use the Reconciliation connector described above in
          the context of the Custom connector. This will be added in a future release.</para>
      </section>
    </section>
    <section>
      <title>Configuring Annotations</title>
      <para>Adding new annotation types or modifying existing ones involves the following three
        files within TEI Publisher or generated apps:</para>
      <variablelist>
        <varlistentry>
          <term><filename>templates/pages/annotate.html</filename></term>
          <listitem>
            <para>The HTML page for the annotation editor</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><filename>modules/annotation-config.xqm</filename></term>
          <listitem>
            <para>Defines how annotations are mapped to TEI</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><filename>odd/annotations.odd</filename></term>
          <listitem>
            <para>The ODD used to render the annotation text view. In generated apps this will live
              in <filename>resources/odd/annotations.odd</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>Let's assume we would like to support an annotation to tag foreign language passages
        with the TEI <tag>foreign</tag> element:</para>
      <para>First, open <filename>templates/pages/annotate.html</filename> in eXide and locate the <tag>
        div</tag> with class <option>toolbar</option>. This contains a list of <tag>
        paper-icon-button</tag> elements. Like many elements in TEI Publisher, <tag>
        paper-icon-button</tag> is a webcomponent from the polymer library, which renders a button
        compliant with Google's material design. You could use any other button-type element here,
        but for consistency, let's stick with <tag>paper-icon-button</tag>. We define our new button
        like this:</para>
      <programlisting>&lt;paper-icon-button class="annotation-action toggle" title="Foreign" data-type="foreign" icon="icons:language" data-shortcut="⌘+⇧+b,ctrl+⇧+b" disabled="disabled">&lt;/paper-icon-button></programlisting>
      <figure>
        <title>Configure a new annotation type</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ann-configure.png" width="800px" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>Make sure to include all the attributes shown:</para>
      <variablelist>
        <varlistentry>
          <term>class</term>
          <listitem>
            <para>must at least contain <option>annotation-action</option>. The <option>toggle</option>
              indicates that this is a toggling annotation, which just switches between on and off
              and does not need further input. For semantic annotations you can also add <option>
              authority</option>, which would trigger the authority lookup.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>title</term>
          <listitem>
            <para>a label to be shown when the mouse is moved over the button.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>data-type</term>
          <listitem>
            <para>indicates the annotation type.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>icon</term>
          <listitem>
            <para>the <link
                xlink:href="http://kevingleason.me/Polymer-Todo/bower_components/iron-icons/demo/index.html"
              >material
              design icon</link> to use</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>data-shortcut</term>
          <listitem>
            <para>an optional keyboard shortcut: here we use command-shift-b for Mac and
              ctrl-shift-b on windows</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>disabled</term>
          <listitem>
            <para>initially disables the button</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>If you reload the annotation editor in the browser, you should now see your new button.
        However, TEI Publisher does not yet know how to translate the new annotation into actual TEI
        markup. To fix this, open <filename>modules/annotation-config.xqm</filename> and search for
        the function <function>anno:annotations</function>. This is a long switch statement with
        cases corresponding to the different annotation types. Add a new case to the top:</para>
      <programlisting>declare function anno:annotations($type as xs:string, $properties as map(*), $content as function(*)) {
    switch ($type)
        case "foreign" return
            &lt;foreign xmlns="http://www.tei-c.org/ns/1.0">{$content()}&lt;/foreign>
    ...
};</programlisting>
      <para>This will simply wrap a <tag>foreign</tag> tag around the existing content. Note that <parameter>
        $content</parameter> is passed in as a function pointer, so it is important to call it as <code>
        $content()</code>. Also note how we need to declare the TEI namespace. Without this
        namespace declaration, the element would not be recognized as TEI.</para>
      <para>Now we can try our new annotation: select a passage, click on the button and see how the
        text is marked as an annotation. The color is chosen automatically. You can also check in
        the TEI preview pane that the annotation is correctly output as a TEI <tag>foreign</tag>
        element.</para>
      <para>However, if you save the annotations, you'll notice that - once the annotation view
        refreshes - the foreign text is rendered in italics, but not marked as an annotation! To fix
        this, we need to modify the ODD used for rendering the annotation view.</para>
      <para>Open <filename>odd/annotations.odd</filename> (named "Annotations"), either in eXide or
        the ODD editor. Add an <tag>elementSpec</tag> for element <tag>foreign</tag> with an inline
        model and a <option>cssClass</option> containing <code>annotation annotation-foreign</code>.</para>
      <programlisting>&lt;elementSpec ident="foreign" mode="change">
    &lt;model behaviour="inline" cssClass="annotation annotation-foreign"/>
&lt;/elementSpec></programlisting>
      <para>If you like, you can also keep the <tag>outputRendition</tag>, which renders the text in
        italic. Key is that you declare the two <emphasis>annotation annotation-foreign</emphasis>
        CSS classes, because those will tell TEI Publisher that the element should be treated as an
        annotation.</para>
      <para>As a general guideline, the ODD rules for annotations should produce simple inline tags.
        They should output the content of the element without any modification. They may use <tag>
        outputRendition</tag> to change the appearance, or supply other parameters (than <option>
        content</option>).</para>
      <para>After saving the ODD, reloading the annotation editor should properly display the <tag>
        foreign</tag> as an annotation and we can start using our new annotation type.</para>
      <para>However, we may not be entirely happy with the simple on/off toggle: it would be much
        better if we could also indicate the used language in <tag>foreign</tag>. This means we have
        to change our annotation from a mere toggle into one which can take an additional parameter:</para>
      <para>To achieve this, go back to <filename>templates/pages/annotate.html</filename> and
        remove the <option>toggle</option> class from the <tag>paper-icon-button</tag>:</para>
      <programlisting>&lt;paper-icon-button class="annotation-action" title="Foreign" data-type="foreign" icon="icons:language" data-shortcut="⌘+⇧+b,ctrl+⇧+b" disabled="disabled">&lt;/paper-icon-button></programlisting>
      <para>We would also like to provide an input field into which the user can enter the language.
        Scroll down to where the <tag>form</tag> is defined and add another input on top:</para>
      <programlisting>&lt;iron-form id="edit-form">
    &lt;form action="">
        &lt;paper-input class="annotation-form foreign" name="lang" label="Language">&lt;/paper-input>
    ...
&lt;/iron-form></programlisting>
      <para>Again we're using a webcomponent for the input to get the material design look and feel.
        The class attribute is particularly important: it must always contain <option>
        annotation-form</option>, followed by the annotation type: <option>foreign</option>. The
        name is arbitrary, but should be unique and we need to remember it for later. The label
        should contain a short title, which will be shown next to the input.</para>
      <para>Finally, we need to change our rule in <filename>modules/annotation-config.xqm</filename>
        to add the new parameter to the generated <tag>foreign</tag> element. Navigate to the file
        and change the <function>anno:annotations</function> function as follows:</para>
      <programlisting>declare function anno:annotations($type as xs:string, $properties as map(*), $content as function(*)) {
    switch ($type)
        case "foreign" return
            &lt;foreign xmlns="http://www.tei-c.org/ns/1.0" xml:lang="{$properties?lang}">{$content()}&lt;/foreign>
    ...
};</programlisting>
      <para>The function receives all the parameters entered into the form fields in the <varname>
        $properties</varname> map. In the form we used <code>name="lang"</code>, so the
        corresponding value is retrieved from the map with <code>$properties?lang</code>.</para>
      <para>That's all. You should now be able to modify your existing foreign annotation, enter a
        language and see how it is output into TEI.</para>

    </section>
    <section>
      <title>Other Considerations</title>
      <para>Web annotations require a clear mapping between the HTML view of the text in the browser
        and the TEI document in the database. It is thus important to respect the following
        restrictions:</para>
      <orderedlist>
        <listitem>
          <para>TEI Publisher's page-by-page display of a text will not work in the annotation
            editor</para>
        </listitem>
        <listitem>
          <para>Likewise, the <option>fill</option> parameter, which causes TEI Publisher to fill up
            short fragments with content from nested divs, should be set to 0 for annotation
            purposes.</para>
        </listitem>
        <listitem>
          <para>The annotation editor can operate on documents with multiple division and will show
            them one after the other. However, those need to be top-level divisions. Therefore the <option>
            depth</option> parameter should be set to 1.</para>
        </listitem>
      </orderedlist>
      <para>To ensure this, TEI Publisher sets the following configuration for the annotate
        collection in <filename>config.xqm</filename>:</para>
      <programlisting language="xquery">declare function config:collection-config($collection as xs:string?, $docUri as xs:string?) {
    switch ($collection)
        (: For annotations we need to overwrite document-specific settings :)
        case "annotate" return
            map {
                "template": "annotate.html",
                "overwrite": true(),
                "depth": 1,
                "fill": 0
            }
        default return
            (: Return empty sequence to use default config :)
            ()
};</programlisting>
      <para>Generated applications should choose similar settings. If you create a separate app just
        for annotations, the following function would suffice to impose the right settings for all
        documents:</para>
      <programlisting language="xquery">declare function config:collection-config($collection as xs:string?, $docUri as xs:string?) {
    map {
        "template": "annotate.html",
        "overwrite": true(),
        "depth": 1,
        "fill": 0
    }
};</programlisting>
    </section>
  </section>
  <section xml:id="production">
    <title>TEI Publisher in production</title>
    <para>Regardless of the installation type, TEI Publisher always runs on an <link
        xlink:show="new" xlink:href="https://exist-db.org">eXist-db database</link> and there are a
      few things to keep in mind for a production system, i.e. one that is publicly available to
      users. We strongly suggest following the recommendations outlined in the <link
        xlink:show="new" xlink:href="https://exist-db.org/exist/apps/doc/production_good_practice"
        >Production Use - Good Practice</link> of the eXist-db documentation. One important point is
      to always run eXist-db in production behind a proxy server, which serves as an intermediary to
      control and protect access to a server on which the database runs. More information about
      proxy servers and eXist-db can be found in the article <link xlink:show="new"
        xlink:href="https://exist-db.org/exist/apps/doc/production_web_proxying">Proxying eXist-db
        behind a Web Server</link>.</para>
    <para>One common function of a proxy server is "hiding" or translating requests to the
      collection where TEI Publisher applications actually live to a shorter and more memorable
      domain name. As a consequence, the internal application links must be correctly set, depending
      on the context in which the app operates. TEI Publisher based apps allow developers to control
      this behaviour via a special variable in <code>modules/config.xqm</code> called
        <code>$config:context-path</code>. </para>
    <para>The variable <code>$config:context-path</code> by default determines the context path
      depending on the presence of the <code>teipublisher.context-path</code> system variable or the
        <code>X-Forwarded-Host</code> HTTP header. If the proxy server sets the
        <code>X-Forwarded-Host</code> HTTP header, TEI Publisher app will recognize it is running
      behind a proxy and adjust the context path on its own.</para>
    <section xml:id="hosting">
      <title>Hosting</title>
      <para>There are various hosting options for the TEI Publisher. Many academic providers and
        research infrastructures (e.g. Huma-Num) routinely support eXist-db and TEI Publisher
        installations while others can do so upon request. A recent <link xlink:show="new"
          xlink:href="https://sources-online.org/">sources-online.org</link> initiative offers
        hosting for editions which includes TEI Publisher and IIIF support.</para>
      <para>Roughly three different types of hosting can be distinguished: <orderedlist>
          <listitem>
            <para>dedicated server</para>
          </listitem>
          <listitem>
            <para>Docker-based installation</para>
          </listitem>
          <listitem>
            <para>static site</para>
                <para>static site</para> 
            <para>static site</para>
          </listitem>
        </orderedlist>
      </para>
      <para><emphasis role="bold">Dedicated server</emphasis> in this context means that a physical
        or virtual machine is available on which eXist-db, TEI Publisher and a proxy server are
        installed and configured.</para>
      <para><emphasis role="bold">Dockerized installation</emphasis> means that a Docker
        configuration has been prepared which automates the tasks of setting up the server with
        eXist, TEI Publisher and all related services (including proxy server). The e-editiones
          <link xlink:show="new"
          xlink:href="https://github.com/eeditiones/teipublisher-docker-compose"
          >teipublisher-docker-compose</link> Github repository describes how to set up such an
        architecture.</para>
      <para>With a <emphasis role="bold">static site</emphasis>, no TEI Publisher and therefore no
        eXist-db is needed for hosting, since the entire application is converted to a pregenerated
        set of static HTML pages which can be hosted on any web server, including at no cost via
        GitHub Pages. It is a particularly fitting solution for smaller editions without extensive
        search features. The article <link xlink:show="new"
          xlink:href="https://www.e-editiones.org/posts/community-event-going-static/">Generating a
          high voltage site by going static</link> describes how such a static site can be generated
        and discusses in detail the advantages and drawbacks of this solution.</para>
    </section>
  </section>

</article>
